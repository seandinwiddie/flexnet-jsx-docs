[
  {
    "title": "Core Concepts - FlexNet JSX Framework",
    "path": "guides/core-concepts.html",
    "content": "GitHub Starter Project Home / Guides / Core Concepts Core Concepts Understanding the fundamental principles behind FlexNet JSX. Functional-First Approach FlexNet JSX is built on a foundation of functional programming principles. This means that we prioritize: Pure Functions Functions that always return the same output for a given input and have no side effects. Immutability Data that cannot be changed after creation, leading to more predictable code. Function Composition Building complex behavior by combining simpler functions together. First-Class Functions Functions that can be passed as arguments, returned from other functions, and assigned to variables. Let's see an example of these principles in action: // Pure function - always returns the same output for the same input const add = (a, b) => a + b; // Function composition - combining simple functions const compose = (f, g) => x => f(g(x)); const double = x => x * 2; const increment = x => x + 1; const doubleAndIncrement = compose(increment, double); // Immutability - creating new objects instead of modifying const updateUser = (user, changes) => ({ ...user, ...changes }); const user = { name: 'Alice', age: 30 }; const updatedUser = updateUser(user, { age: 31 }); // user remains unchanged, updatedUser is a new object JSX Runtime The JSX runtime in FlexNet transforms JSX syntax into function calls that create and manage virtual DOM elements. Key JSX Runtime Concepts createElement : Function that creates virtual DOM elements Virtual DOM : Lightweight representation of the actual DOM Reconciliation : Efficient algorithm for updating the DOM Components : Pure functions that return virtual DOM elements Here's how JSX transforms into function calls: JSX Syntax const element = ( &lt;div className=\"container\"&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;p&gt;Welcome to FlexNet JSX&lt;/p&gt; &lt;/div&gt; ); Transformed Output const element = createElement( 'div', { className: 'container' }, createElement('h1', null, 'Hello, world!'), createElement('p', null, 'Welcome to FlexNet JSX') ); Type System FlexNet's type system provides functional data types that make code more predictable and error-resistant. These types enforce certain patterns and handle edge cases elegantly. M Maybe Handling optional values safely // Instead of null checks everywhere const getUserName = user => Maybe.fromNullable(user) .map(u => u.name) .getOrElse('Guest'); Learn more about Maybe &rarr; E Either Representing success or failure // Handle errors without exceptions const divide = (a, b) => b === 0 ? Either.Left('Division by zero') : Either.Right(a / b); Learn more about Either &rarr; R Result Representing computation results // Track operation results with context const validateUser = user => user.name.length > 0 ? Result.Ok(user) : Result.Err('Name cannot be empty'); Learn more about Result &rarr; State Management FlexNet uses a functional approach to state management that emphasizes immutability and pure functions for state transitions. State Management Principles 1 Immutable State State is never modified directly; instead, new state objects are created. 2 Pure Update Functions State changes are defined as pure functions that take the current state and return a new state. 3 Subscription Model Components subscribe to state changes and re-render when state updates. 4 Functional Composition Complex state transformations are built by composing simpler functions. Here's a basic example of state management with FlexNet: import { createStore } from './src/systems/state/store.js'; // Create a store with initial state const store = createStore({ count: 0, user: null }); // Define pure update functions const incrementCount = state => ({ ...state, count: state.count + 1 }); const setUser = user => state => ({ ...state, user }); // Update state by passing update functions store.update(incrementCount); store.update(setUser({ id: 1, name: 'Alice' })); // Subscribe to state changes store.subscribe(state => { console.log('New state:', state); // Render UI with new state }); Effect System The effect system in FlexNet provides a way to handle side effects (like API calls, timers, etc.) in a functional way. Effect System Features Isolation of side effects from pure logic Functional composition of effects Automatic cleanup of resources Testable effect handlers Example of using the effect system: import { createEffect, runEffect } from './src/systems/effects/effect.js'; // Create an effect for fetching data const fetchUserEffect = userId => createEffect(({ onSuccess, onError }) => { const controller = new AbortController(); const signal = controller.signal; fetch(`/api/users/${userId}`, { signal }) .then(response => response.json()) .then(data => onSuccess(data)) .catch(err => onError(err)); // Return cleanup function return () => controller.abort(); }); // Run the effect const cleanup = runEffect(fetchUserEffect(123), { onSuccess: user => console.log('User:', user), onError: err => console.error('Error:', err) }); // Later, if needed: cleanup(); // Aborts the fetch if it's still in progress Putting It All Together Let's see how these concepts work together in a simple counter application: import { compose, Maybe } from './src/core/runtime/runtime.js'; import { createStore } from './src/systems/state/store.js'; import { createElement, render } from './src/core/runtime/jsx.js'; import { createEffect, runEffect } from './src/systems/effects/effect.js'; // === State Management === const store = createStore(Maybe.Just(0)); // Pure update functions const increment = n => Maybe.Just(n + 1); const decrement = n => Maybe.Just(Math.max(0, n - 1)); // === Effects === const logEffect = message => createEffect(() => { console.log(message); return () => console.log('Effect cleaned up'); }); // === Component === const Counter = ({ count, onIncrement, onDecrement }) => { // Run an effect when the component renders runEffect(logEffect(`Counter rendered with count: ${count}`)); return createElement('div', { className: 'counter' }, createElement('h2', null, `Count: ${count}`), createElement('div', { className: 'buttons' }, createElement('button', { onClick: compose(onIncrement, increment) }, 'Increment'), createElement('button', { onClick: compose(onDecrement, decrement) }, 'Decrement') ) ); }; // === Application Init === function init() { // Subscribe to state changes store.subscribe(count => { render( createElement(Counter, { count: count, onIncrement: store.update, onDecrement: store.update }), document.getElementById('root') ); }); } document.addEventListener('DOMContentLoaded', init); Next Steps JSX Runtime Dive deeper into the JSX runtime implementation. Type System Learn more about FlexNet's functional type system. State Management Explore state management in depth. Todo App Example See these concepts in a complete application. Ready to start building? Check out our Quick Start Guide to create your first FlexNet JSX application."
  },
  {
    "title": "Installation - FlexNet JSX Framework",
    "path": "guides/installation.html",
    "content": "GitHub Starter Project Installing FlexNet JSX Framework FlexNet JSX is designed to be easy to install and integrate into your projects. Since it follows a zero-dependencies approach, the installation process is straightforward. Note: FlexNet JSX requires no external dependencies and uses browser-native implementation only. Installation Methods Method 1: Use a Starter Project (Recommended) The easiest way to get started with FlexNet JSX is to use one of our pre-configured starter projects. These projects provide everything you need to start developing right away. Full-Featured Starter Project For a comprehensive implementation with all framework features: # Clone the repository (replace with your method of obtaining the code) git clone https://github.com/flexnet/flexnet-jsx.git cd flexnet-jsx # Navigate to the full-featured starter cd starter-project # Start a simple development server python -m http.server 3000 # Open your browser to http://localhost:3000 The full-featured starter includes: Complete type system (Maybe, Either, Result) Advanced security features Error boundaries Effect system with cleanup Event system Advanced rendering Utility functions Minimal Starter Project For a lightweight implementation focusing on core concepts: # Navigate to the minimal starter cd starter-project-minimal # Start a simple development server python -m http.server 3000 # Open your browser to http://localhost:3000 The minimal starter includes: Essential types (Maybe monad) Basic security (XSS prevention) Functional core Simple state management Counter example Method 2: Integrate into an Existing Project You can add FlexNet JSX to an existing project by including it directly in your HTML or importing it into your JavaScript modules. Include in HTML &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;FlexNet JSX Project&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"root\"&gt;&lt;/div&gt; &lt;script type=\"module\" src=\"path/to/flexnet/src/core/runtime/jsx.js\"&gt;&lt;/script&gt; &lt;script type=\"module\" src=\"path/to/your/app.js\"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; Import in JavaScript // Import core FlexNet functionality import { jsx, render } from './path/to/flexnet/src/core/runtime/jsx.js'; import { Maybe } from './path/to/flexnet/src/core/types/maybe.js'; import { createStore } from './path/to/flexnet/src/systems/state/store.js'; import { compose } from './path/to/flexnet/src/core/functions/composition.js'; // Now use FlexNet in your application const App = () => { // Your application code here }; Method 3: Manual Setup (Advanced) For complete control over your project structure, you can manually set up a FlexNet JSX project following the recommended directory structure. 1. Create Project Structure mkdir -p my-flexnet-project/src/{core/{runtime,types,functions},systems/{render,state,effects,events},features,utils} mkdir -p my-flexnet-project/public mkdir -p my-flexnet-project/tests 2. Create Core Files Create the necessary core files based on the FlexNet architecture: src/core/runtime/jsx.js - JSX runtime implementation src/core/types/maybe.js - Maybe type implementation src/core/types/either.js - Either type implementation src/core/types/result.js - Result type implementation src/core/functions/composition.js - Function composition utilities src/systems/state/store.js - State management implementation src/systems/render/functions.js - Rendering system 3. Create HTML Entry Point &lt;!-- public/index.html --&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;FlexNet JSX Project&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"root\"&gt;&lt;/div&gt; &lt;script type=\"module\" src=\"../src/index.js\"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 4. Create Main Entry Point // src/index.js import { jsx, render } from './core/runtime/jsx.js'; import { createApp } from './features/app.js'; const app = createApp(); render(app, document.getElementById('root')); Directory Structure FlexNet JSX follows a specific directory structure that promotes functional programming principles, separation of concerns, and maintainability. Here's the recommended structure: my-project/ ├── src/ │ ├── core/ # Core JSX functionality │ │ ├── runtime/ # JSX runtime │ │ │ ├── jsx.js │ │ │ └── transform.js │ │ ├── types/ # Type system │ │ │ ├── maybe.js │ │ │ ├── either.js │ │ │ └── result.js │ │ └── functions/ # Core functions │ │ ├── composition.js │ │ └── transforms.js │ │ │ ├── systems/ # Framework systems │ │ ├── render/ # Rendering │ │ ├── state/ # State management │ │ ├── effects/ # Side effects │ │ └── events/ # Event handling │ │ │ ├── features/ # Your app features │ │ └── counter/ # Example feature │ │ ├── functions.js │ │ └── index.js │ │ │ └── utils/ # Utilities │ ├── array.js │ └── function.js │ ├── public/ # Static assets │ └── index.html │ └── tests/ # Test files └── features/ └── counter/ └── counter.test.js Verification After installing FlexNet JSX, you can verify that it's working correctly by creating a simple counter application. The example below shows how to create a counter using FlexNet JSX: // src/features/counter/functions.js import { Maybe } from '../../core/types/maybe.js'; export const increment = n => n + 1; export const decrement = n => n - 1; // src/features/counter/index.js import { jsx } from '../../core/runtime/jsx.js'; import { createStore } from '../../systems/state/store.js'; import { increment, decrement } from './functions.js'; import { Maybe } from '../../core/types/maybe.js'; // Create a store with initial count of 0 const store = createStore(Maybe.Just(0)); // Counter component const Counter = () => { const count = store.getState(); return jsx('div', null, [ jsx('h2', null, `Count: ${count.value}`), jsx('button', { onClick: () => store.update(c => Maybe.Just(decrement(c.value))) }, '-'), jsx('span', { style: 'margin: 0 10px;' }, count.value.toString()), jsx('button', { onClick: () => store.update(c => Maybe.Just(increment(c.value))) }, '+') ]); }; // Render component and subscribe to state changes const init = (rootId) => { const rootElement = document.getElementById(rootId); if (!rootElement) return; const render = () => { // Clear container while (rootElement.firstChild) { rootElement.removeChild(rootElement.firstChild); } // Render counter rootElement.appendChild(Counter()); }; // Initial render render(); // Subscribe to state changes store.subscribe(() => { render(); }); }; export default init; Browser Support FlexNet JSX is designed to work with modern browsers that support ES6 features. It is tested and supported on: Chrome (latest) Firefox (latest) Safari (latest) Edge (latest) Next Steps Now that you've installed FlexNet JSX, you can: Explore the Quick Start guide to build your first FlexNet JSX application Learn about Core Concepts to understand the fundamental principles Check out the Counter Example to see FlexNet JSX in action ← Previous: Introduction Next: Quick Start →"
  },
  {
    "title": "Introduction - FlexNet JSX Framework",
    "path": "guides/introduction.html",
    "content": "GitHub Starter Project Home / Getting Started / Introduction Introduction to FlexNet JSX FlexNet JSX is a lightweight, functional JavaScript framework for building modern web applications using pure functions, immutable data, and functional composition. FlexNet is ideal for developers who value code that is predictable, maintainable, and testable. Its functional approach eliminates an entire class of common JavaScript bugs. What is FlexNet JSX? FlexNet JSX is a JavaScript framework built on functional programming principles with a JSX-like syntax. Unlike React or other mainstream frameworks, FlexNet emphasizes: Pure Functions - Components are pure functions with no side effects Immutable Data - State changes create new state rather than mutating existing state Functional Composition - Building complex behavior through function composition Zero Dependencies - No external dependencies, using only browser native capabilities Type Safety - Functional type system with Maybe, Either, and Result types Why Choose FlexNet? Predictable Behavior Pure functions always produce the same output for a given input, making behavior predictable and reproducible. Easier Testing Pure functions are inherently easier to test as they don't depend on external state or produce side effects. Fewer Bugs Immutable data and functional composition eliminate common sources of bugs like race conditions and state inconsistencies. Lightweight & Fast Zero dependencies and minimal abstraction lead to smaller bundle sizes and faster execution. Core Principles 1. Functions as First-Class Citizens In FlexNet, functions are the primary building blocks. Components are pure functions that take props as input and return elements as output. // A simple functional component const Greeting = ({ name }) => createElement('h1', null, `Hello, ${name}!`); // Usage render( createElement(Greeting, { name: 'World' }), document.getElementById('root') ); 2. Immutable State Management State is never mutated directly. Instead, state updates create new state objects, preserving the old state. import { createStore } from './src/systems/state/store.js'; import { Maybe } from './src/core/types/maybe.js'; // Create an immutable store const store = createStore(Maybe.Just({ count: 0 })); // State updates return new state const increment = state => Maybe.Just({ ...state, count: state.count + 1 }); // Update state store.update(increment); 3. Functional Composition Complex behaviors are built through function composition rather than inheritance or imperative code. import { compose } from './src/core/runtime/runtime.js'; // Simple functions const add5 = x => x + 5; const multiply2 = x => x * 2; const toString = x => `Result: ${x}`; // Compose them into a single function const process = compose( toString, multiply2, add5 ); // Use the composed function console.log(process(10)); // \"Result: 30\" 4. Type Safety with Functional Types FlexNet provides functional types like Maybe, Either, and Result for safer handling of optional values and error cases. import { Maybe } from './src/core/types/maybe.js'; // Safe access to potentially missing values const getUserName = user => Maybe.fromNullable(user) .map(u => u.profile) .chain(p => Maybe.fromNullable(p.name)) .getOrElse('Guest'); // No more null reference errors! const name1 = getUserName({ profile: { name: 'Alice' } }); // \"Alice\" const name2 = getUserName({ profile: null }); // \"Guest\" const name3 = getUserName(null); // \"Guest\" Key Features JSX-like Syntax FlexNet provides a JSX-compatible runtime that lets you write declarative UI code: // JSX syntax (requires transpilation) const App = () => ( FlexNet App Building UIs with pure functions ); // Equivalent createElement calls const App = () => createElement('div', { className: 'app' }, createElement('h1', null, 'FlexNet App'), createElement('p', null, 'Building UIs with pure functions') ); Immutable Store FlexNet includes a simple yet powerful immutable store for state management: import { createStore } from './src/systems/state/store.js'; import { Maybe } from './src/core/types/maybe.js'; // Create a store with initial state const store = createStore(Maybe.Just({ user: null, isLoading: false, error: null })); // Subscribe to state changes store.subscribe(state => { console.log('New state:', state); renderApp(state); }); // Update state with pure functions const setLoading = loading => state => Maybe.Just({ ...state, isLoading: loading }); const setUser = user => state => Maybe.Just({ ...state, user, isLoading: false }); // Use the store store.update(setLoading(true)); fetchUser().then(user => store.update(setUser(user))); Functional Error Handling FlexNet provides functional types for safer error handling: import { Result } from './src/core/types/result.js'; // Function that returns a Result const divide = (a, b) => b === 0 ? Result.Error('Division by zero') : Result.Ok(a / b); // Using the Result const result = divide(10, 2) .map(value => value * 2) .mapError(err => `Error: ${err}`) .fold( error => console.error(error), value => console.log(`Result: ${value}`) ); Comparison with Other Frameworks Feature FlexNet React Vue Programming Paradigm Purely Functional Mixed (Functional & OOP) Mixed (Reactive & OOP) State Management Immutable Store Hooks / Context / Redux Reactive State / Vuex Bundle Size Very Small ( Medium (~ 40KB) Medium (~ 30KB) Type Safety Built-in Functional Types Via TypeScript Via TypeScript Learning Curve Steeper (FP concepts) Moderate Gentle Getting Started Ready to try FlexNet? Here's how to get started: 1. Installation Add FlexNet to your project Installation Guide → 2. Quick Start Build your first FlexNet app Quick Start Guide → 3. Examples Learn from sample applications View Examples → Who is FlexNet For? FlexNet is ideal for developers and teams who: Value code that is predictable, testable, and maintainable Appreciate functional programming principles Need a lightweight solution with minimal dependencies Want to avoid common JavaScript bugs and edge cases Build applications where reliability is critical While FlexNet has a steeper learning curve for developers unfamiliar with functional programming, the benefits in code quality and maintainability make it worth the investment. Community & Support FlexNet is an open-source project with a growing community. Here's how to get involved: GitHub Repository - Star the project, report issues, and contribute code Discord Community - Join discussions and get help from other users Official Blog - Learn about updates, best practices, and use cases Next: Installation"
  },
  {
    "title": "Quick Start - FlexNet JSX Framework",
    "path": "guides/quickstart.html",
    "content": "GitHub Starter Project Home / Guides / Quick Start Quick Start Get up and running with FlexNet JSX in minutes with this quick start guide. Prerequisites Before you begin, ensure you have the following installed: A modern web browser (Chrome, Firefox, Safari, or Edge) Basic knowledge of JavaScript and HTML A code editor of your choice A local development server (optional but recommended) Installation Options Option 1: Direct Script Import The simplest way to get started is by directly importing the FlexNet JSX framework via a script tag: &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;FlexNet JSX App&lt;/title&gt; &lt;script type=\"module\" src=\"path/to/jsx/src/index.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"root\"&gt;&lt;/div&gt; &lt;script type=\"module\"&gt; // Your FlexNet JSX code will go here &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; Option 2: Use a Starter Project For a more comprehensive setup, we recommend using one of our starter projects: Full-Featured Starter A comprehensive implementation with all framework features. # Clone the repo (or download manually) cd starter-project python -m http.server 3000 # Open http://localhost:3000 Minimal Starter A lightweight implementation for learning the core concepts. # Clone the repo (or download manually) cd starter-project-minimal python -m http.server 3000 # Open http://localhost:3000 Your First FlexNet JSX Component Let's create a simple counter component to demonstrate the core concepts of FlexNet JSX: // Import core modules import { compose, Maybe } from './src/core/runtime/runtime.js'; import { createStore } from './src/systems/state/store.js'; import { createElement, render } from './src/core/runtime/jsx.js'; // Create an immutable store with initial state const store = createStore(Maybe.Just(0)); // Pure function for state update const increment = n => Maybe.Just(n + 1); const decrement = n => Maybe.Just(Math.max(0, n - 1)); // Counter component as a pure function const Counter = ({ count, onIncrement, onDecrement }) => createElement('div', { className: 'counter' }, createElement('h2', null, `Count: ${count}`), createElement('div', { className: 'buttons' }, createElement('button', { onClick: compose(onIncrement, increment) }, 'Increment'), createElement('button', { onClick: compose(onDecrement, decrement) }, 'Decrement') ) ); // Initialize the application function init() { // Subscribe to state changes and render on each update store.subscribe(count => { render( createElement(Counter, { count: count, onIncrement: store.update, onDecrement: store.update }), document.getElementById('root') ); }); } // Run the application when DOM is ready document.addEventListener('DOMContentLoaded', init); Step-by-Step Explanation Imports : We import the necessary functions from the FlexNet JSX framework. compose : For function composition Maybe : For handling optional values createStore : For state management createElement, render : For creating and rendering components Store Creation : We create an immutable store with an initial value of 0 wrapped in a Maybe.Just . State Update Functions : We define pure functions for incrementing and decrementing the counter. Component Definition : We define a Counter component as a pure function that takes props and returns a virtual DOM structure. Rendering : We subscribe to state changes and render the component with the current state. Adding Styles Let's add some basic CSS to style our counter: &lt;style&gt; .counter { font-family: system-ui, -apple-system, sans-serif; max-width: 300px; margin: 2rem auto; padding: 1.5rem; border-radius: 0.5rem; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); background-color: white; text-align: center; } .buttons { display: flex; gap: 0.5rem; justify-content: center; margin-top: 1rem; } button { background-color: #3b82f6; color: white; border: none; padding: 0.5rem 1rem; border-radius: 0.25rem; cursor: pointer; font-weight: 500; } button:hover { background-color: #2563eb; } &lt;/style&gt; Next Steps Now that you've created your first FlexNet JSX component, you can explore more advanced features: State Management Learn about FlexNet's immutable state management system. Type System Explore the functional type system with Maybe, Either, and Result. Effects Handle side effects in a pure functional way. Todo App Example See a more complex example with FlexNet JSX. Tip For the best development experience, we recommend going through our Core Concepts guide to understand the fundamental principles behind FlexNet JSX."
  },
  {
    "title": "Functional Programming - FlexNet JSX Framework",
    "path": "core/functions.html",
    "content": "GitHub Starter Project Home / Core / Functions Functional Programming FlexNet JSX is built on functional programming principles, providing a set of utilities to work with functions in a composable, pure way. Core Function Utilities FlexNet provides a set of utilities for working with functions in a functional programming style: compose The compose function allows you to combine multiple functions together, applying them from right to left. import { compose } from './src/core/runtime/runtime.js'; // Example functions const double = x => x * 2; const increment = x => x + 1; const square = x => x * x; // Compose functions: (x => square(double(increment(x)))) const doubleIncrementAndSquare = compose(square, double, increment); // Usage doubleIncrementAndSquare(3); // Result: 64 // Calculation: square(double(increment(3))) = square(double(4)) = square(8) = 64 pipe The pipe function is similar to compose , but applies the functions from left to right. import { pipe } from './src/core/runtime/runtime.js'; // Example functions const double = x => x * 2; const increment = x => x + 1; const square = x => x * x; // Pipe functions: (x => square(increment(double(x)))) const doubleIncrementAndSquare = pipe(double, increment, square); // Usage doubleIncrementAndSquare(3); // Result: 49 // Calculation: square(increment(double(3))) = square(increment(6)) = square(7) = 49 curry The curry function transforms a function that takes multiple arguments into a sequence of functions that each take a single argument. import { curry } from './src/core/runtime/runtime.js'; // Original function with multiple arguments const add = (a, b, c) => a + b + c; // Curried version const curriedAdd = curry(add); // Usage curriedAdd(1)(2)(3); // Result: 6 // Partial application const add1 = curriedAdd(1); const add1And2 = add1(2); add1And2(3); // Result: 6 memoize The memoize function creates a cached version of a function, which remembers the results for previous inputs to avoid recalculation. import { memoize } from './src/core/runtime/runtime.js'; // Expensive computation const fibonacci = n => { if (n { if (n Pure Functions FlexNet JSX encourages the use of pure functions, which have the following characteristics: They always return the same output for the same input They don't cause side effects (like modifying global state or making API calls) They don't depend on external state that might change Benefits of Pure Functions Easier to test More predictable Easier to debug Can be safely memoized Can be parallelized Example: Pure vs. Impure Functions // Impure function (depends on external state) let counter = 0; function impureIncrement() { counter++; return counter; } // Pure function (same input always gives same output) function pureIncrement(count) { return count + 1; } Higher-Order Functions Higher-order functions are functions that take other functions as arguments or return functions as results. FlexNet JSX makes extensive use of higher-order functions for composition, event handling, and more. Function as Data In FlexNet JSX, functions are treated as first-class citizens, meaning they can be: Assigned to variables Passed as arguments to other functions Returned from functions Stored in data structures Example: Event Handler with Composition import { compose } from './src/core/runtime/runtime.js'; import { createStore } from './src/systems/state/store.js'; import { createElement } from './src/core/runtime/jsx.js'; // Create a store with initial state const store = createStore({ count: 0 }); // Pure functions for state transformations const increment = state => ({ count: state.count + 1 }); const double = state => ({ count: state.count * 2 }); const reset = () => ({ count: 0 }); // Component with composed event handlers const Counter = ({ state, update }) => createElement('div', null, createElement('p', null, `Count: ${state.count}`), createElement('button', { onClick: () => update(increment) }, 'Increment'), createElement('button', { onClick: () => update(compose(double, increment)) }, 'Increment & Double'), createElement('button', { onClick: () => update(reset) }, 'Reset') ); Functional Updates with Immutability FlexNet JSX follows the principle of immutability when updating state. Instead of modifying existing objects, we create new ones with the desired changes. Immutable Update Patterns // Original object const user = { name: 'John', age: 30, address: { city: 'New York', zip: '10001' } }; // Bad: Mutating the original object function badUpdateAge(user, newAge) { user.age = newAge; // Mutation! return user; } // Good: Creating a new object with the updated property function goodUpdateAge(user, newAge) { return { ...user, age: newAge }; } // Good: Updating a nested property function updateCity(user, newCity) { return { ...user, address: { ...user.address, city: newCity } }; } Function Utilities in FlexNet FlexNet provides additional utilities for working with functions: debounce The debounce function limits how often a function can be called, delaying execution until after a specified time has passed since the last call. import { debounce } from './src/core/runtime/runtime.js'; // Original function const handleSearch = (query) => { // Perform search operation console.log(`Searching for: ${query}`); }; // Debounced version - only executes after 300ms of inactivity const debouncedSearch = debounce(handleSearch, 300); // Usage searchInput.addEventListener('input', (e) => { debouncedSearch(e.target.value); }); throttle The throttle function ensures a function is called at most once in a specified time period. import { throttle } from './src/core/runtime/runtime.js'; // Original function const handleScroll = () => { // Perform scroll-related operation console.log('Scroll event handled'); }; // Throttled version - executes at most once every 200ms const throttledScroll = throttle(handleScroll, 200); // Usage window.addEventListener('scroll', throttledScroll); Best Practice When working with FlexNet JSX, prefer using pure functions and functional composition over imperative approaches. This leads to more maintainable, testable, and predictable code. Next Steps Type System Learn about FlexNet's functional type system with Maybe, Either, and Result. Security Explore FlexNet's security features and best practices."
  },
  {
    "title": "JSX Runtime - FlexNet JSX Framework",
    "path": "core/jsx-runtime.html",
    "content": "GitHub Starter Project Home / Core / JSX Runtime JSX Runtime The FlexNet JSX Runtime is a lightweight, functional implementation of JSX that enables declarative UI programming using JavaScript functions. Note Unlike React, FlexNet JSX is a pure functional implementation with zero dependencies and a focus on immutability and composition. How JSX Works in FlexNet In FlexNet, JSX is transpiled to function calls that create virtual DOM nodes. These nodes are then rendered to the actual DOM through a pure rendering function. The createElement Function At the core of FlexNet's JSX runtime is the createElement function, which transforms JSX syntax into function calls. import { createElement } from './src/core/runtime/jsx.js'; // JSX like: // &lt;div className=\"container\"&gt;Hello world&lt;/div&gt; // Gets converted to: createElement('div', { className: 'container' }, 'Hello world'); Functional Components FlexNet components are pure functions that accept props and return elements: // A simple functional component const Greeting = ({ name }) => createElement('h1', null, `Hello, ${name}!`); // Using the component const element = createElement(Greeting, { name: 'World' }); // JSX equivalent would be: // &lt;Greeting name=\"World\" /&gt; Core JSX Runtime API Function Description Usage createElement Creates virtual DOM elements createElement(type, props, ...children) render Renders elements to the DOM render(element, container) Fragment Group elements without creating extra nodes createElement(Fragment, null, ...children) createContext Creates a context for data sharing createContext(defaultValue) Rendering with Pure Functions FlexNet uses pure functions for rendering, which means: Predictable rendering behavior No side effects during the render phase Immutable data patterns Functional composition for component building Rendering Example import { createElement, render } from './src/core/runtime/jsx.js'; import { compose, Maybe } from './src/core/runtime/runtime.js'; // Pure component function const App = ({ message }) => createElement('div', { className: 'app' }, createElement('h1', null, 'FlexNet App'), createElement('p', null, message || 'No message provided') ); // Render function - pure with no side effects render( createElement(App, { message: 'Hello, World!' }), document.getElementById('root') ); JSX vs createElement JSX is syntactic sugar over the createElement function. Here's how they compare: JSX Syntax const element = ( &lt;div className=\"container\"&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;p&gt;Paragraph&lt;/p&gt; &lt;/div&gt; ); createElement Calls const element = createElement( 'div', { className: 'container' }, createElement('h1', null, 'Title'), createElement('p', null, 'Paragraph') ); Integration with FlexNet's Type System The JSX runtime is designed to work seamlessly with FlexNet's functional type system: import { createElement } from './src/core/runtime/jsx.js'; import { Maybe } from './src/core/types/maybe.js'; // Using Maybe for optional props const UserProfile = ({ user }) => { // Safely access potentially missing user data const username = Maybe.fromNullable(user) .map(u => u.username) .getOrElse('Guest'); return createElement('div', null, createElement('h2', null, `Welcome, ${username}!`) ); }; Key Differences from React Pure Functional: FlexNet JSX is designed around pure functions and immutability, avoiding class components entirely. No Virtual DOM Diffing: FlexNet uses a more direct approach to DOM updates without the overhead of a complex diffing algorithm. Integrated Type System: The runtime is built to work with FlexNet's functional type system (Maybe, Either, Result). No Dependencies: FlexNet JSX has zero external dependencies and a much smaller footprint. Functional Composition: Component composition is achieved through function composition rather than component nesting. Further Reading JSX API Reference Detailed API documentation for the JSX runtime Counter Example See JSX in action with a simple counter application Function Composition Learn how function composition powers FlexNet components Render System Understand how the rendering process works"
  },
  {
    "title": "Security - FlexNet JSX Framework",
    "path": "core/security.html",
    "content": "GitHub Starter Project Home / Core / Security Security FlexNet JSX is designed with security as a core principle, providing built-in protections against common web vulnerabilities. Security Features FlexNet JSX provides several built-in security features to protect your application from common web vulnerabilities: XSS Protection Cross-Site Scripting (XSS) is one of the most common web vulnerabilities. FlexNet JSX automatically escapes content to prevent XSS attacks. Automatic Content Escaping // User input (potentially malicious) const userInput = ''; // JSX will automatically escape this content const component = createElement('div', null, userInput); // Rendered as plain text, not as HTML // Output: &lt;script&gt;alert(\"XSS Attack!\")&lt;/script&gt; Warning: dangerouslySetInnerHTML For cases where you need to render HTML content, FlexNet provides dangerouslySetInnerHTML similar to React, but use it with extreme caution: // Only use with content you fully trust and have sanitized createElement('div', { dangerouslySetInnerHTML: { __html: trustedAndSanitizedHTML } }); Always sanitize HTML content before using this property, preferably with a library like DOMPurify. Input Validation FlexNet provides utilities for validating input data, helping to prevent injection attacks and data corruption. import { validate } from './src/core/security/validation.js'; // Define validation schema const userSchema = { username: { type: 'string', minLength: 3, maxLength: 20, pattern: /^[a-zA-Z0-9_]+$/ }, age: { type: 'number', min: 13, max: 120 } }; // Validate user input const userInput = { username: 'john_doe', age: 25 }; // Returns Either.Right(userInput) if valid, // Either.Left(validationErrors) if invalid const validationResult = validate(userInput, userSchema); Content Security Policy Support FlexNet is designed to work well with Content Security Policy (CSP), a browser security feature that helps prevent XSS and other code injection attacks. Recommended CSP Configuration &lt;meta http-equiv=\"Content-Security-Policy\" content=\" default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; connect-src 'self' https://api.example.com; font-src 'self'; object-src 'none'; media-src 'self'; frame-src 'none'; \"&gt; Secure State Management FlexNet's immutable state management approach provides security benefits by preventing direct mutation of state. Security Benefits of Immutability Prevents unauthorized state modifications Makes state changes explicit and traceable Enables time-travel debugging for identifying security issues Simplifies testing and verification of security controls Example: Secure State Updates import { createStore } from './src/systems/state/store.js'; import { validate } from './src/core/security/validation.js'; // Initial state const initialState = { user: null, isAuthenticated: false, permissions: [] }; // Create store const store = createStore(initialState); // Validation schema const loginSchema = { username: { type: 'string', minLength: 1 }, password: { type: 'string', minLength: 8 } }; // Secure login handler function handleLogin(credentials) { // Validate input first const validationResult = validate(credentials, loginSchema); // Handle validation errors if (validationResult.isLeft()) { return validationResult; // Return validation errors } // Proceed with login (using valid credentials) return authenticateUser(credentials) .then(authResult => { // Update state only if authentication succeeded if (authResult.success) { store.update(state => ({ ...state, user: authResult.user, isAuthenticated: true, permissions: authResult.permissions })); return authResult; } return authResult; }); } Secure Error Handling FlexNet's functional error handling with Maybe, Either, and Result types prevents sensitive information leakage and provides structured error handling. Example: Secure Error Handling with Result import { Result } from './src/core/types/result.js'; // User authentication function function authenticateUser(credentials) { return fetchUserData(credentials) .then(response => { if (response.ok) { return response.json().then(data => Result.Ok(data)); } // Security best practice: don't expose detailed error information if (response.status === 401) { return Result.Error('Invalid credentials'); } else if (response.status === 429) { return Result.Error('Too many attempts. Please try again later.'); } else { return Result.Error('Authentication failed. Please try again.'); } }) .catch(error => { // Log the detailed error internally for debugging console.error('Authentication error:', error); // Return a generic error message to the user return Result.Error('An unexpected error occurred. Please try again.'); }); } CSRF Protection Cross-Site Request Forgery (CSRF) is a type of attack that tricks users into executing unwanted actions on a web application they're authenticated to. API Request Helpers FlexNet provides API request helpers with built-in CSRF protection: import { apiRequest } from './src/core/security/api.js'; // The apiRequest function automatically adds CSRF tokens to requests apiRequest('/api/user/profile', { method: 'POST', body: JSON.stringify(userData) }) .then(result => { // Handle the result safely using the Result type result.match({ Ok: data => updateUserProfile(data), Error: error => displayError(error) }); }); Security Best Practices Always validate user input on both client and server sides Use HTTPS for all connections Implement proper authentication and authorization Keep dependencies updated to prevent known vulnerabilities Apply the principle of least privilege Implement proper logging and monitoring for security events Next Steps Error Handling Learn about FlexNet's comprehensive error handling system. State Management Explore FlexNet's secure state management system."
  },
  {
    "title": "Type System - FlexNet JSX Framework",
    "path": "core/types.html",
    "content": "GitHub Starter Project Home / Core / Type System Type System FlexNet JSX implements a functional type system inspired by algebraic data types from functional programming languages. These types help handle common programming challenges like optional values, error handling, and operation outcomes in a pure functional way. Note FlexNet's type system is designed to be used with JavaScript's native capabilities, without requiring a compile-time type checker like TypeScript or Flow. However, it's fully compatible with these tools if you choose to use them. Core Types Overview FlexNet JSX includes three fundamental types that form the backbone of the type system: Maybe: For handling optional values and eliminating null checks. Either: For handling branching logic and error cases with explicit paths. Result: For capturing operation outcomes and handling exceptions functionally. These types follow the principles of functional programming, particularly the concept of monads, which allows for composition and chaining of operations. Maybe Type The Maybe type represents optional values in a functional way. It eliminates the need for null checks and makes code safer and more predictable. Structure // src/core/types/maybe.js const Maybe = { Just: value => ({ type: 'Just', value, map: fn => Maybe.Just(fn(value)), chain: fn => fn(value), getOrElse: defaultValue => value }), Nothing: () => ({ type: 'Nothing', map: fn => Maybe.Nothing(), chain: fn => Maybe.Nothing(), getOrElse: defaultValue => defaultValue }), fromNullable: value => value != null ? Maybe.Just(value) : Maybe.Nothing(), map: fn => maybe => maybe.type === 'Just' ? Maybe.Just(fn(maybe.value)) : Maybe.Nothing(), chain: fn => maybe => maybe.type === 'Just' ? fn(maybe.value) : Maybe.Nothing(), getOrElse: defaultValue => maybe => maybe.type === 'Just' ? maybe.value : defaultValue }; Key Concepts Just - Contains a value Nothing - Represents no value map - Transform the value if it exists chain - Apply a function that returns a Maybe getOrElse - Extract the value or provide a default Usage Example import Maybe from '../core/types/maybe.js'; // Safe access to potentially null/undefined values const getUserName = user => Maybe.fromNullable(user) .chain(u => Maybe.fromNullable(u.profile)) .chain(p => Maybe.fromNullable(p.name)) .getOrElse('Anonymous'); // Usage const user1 = { profile: { name: 'Alice' }}; const user2 = { profile: null }; const user3 = null; console.log(getUserName(user1)); // 'Alice' console.log(getUserName(user2)); // 'Anonymous' console.log(getUserName(user3)); // 'Anonymous' For complete details on the Maybe type, see the Maybe API Reference . Either Type The Either type represents values that can be one of two possibilities, typically used for error handling or branching logic. Structure // src/core/types/either.js const Either = { Left: value => ({ type: 'Left', value, map: fn => Either.Left(value), chain: fn => Either.Left(value), fold: (leftFn, rightFn) => leftFn(value) }), Right: value => ({ type: 'Right', value, map: fn => Either.Right(fn(value)), chain: fn => fn(value), fold: (leftFn, rightFn) => rightFn(value) }), fromNullable: (value, errorMsg = 'Value is null') => value != null ? Either.Right(value) : Either.Left(errorMsg), map: fn => either => either.type === 'Right' ? Either.Right(fn(either.value)) : either, chain: fn => either => either.type === 'Right' ? fn(either.value) : either, fold: (leftFn, rightFn) => either => either.type === 'Right' ? rightFn(either.value) : leftFn(either.value) }; Key Concepts Left - Typically represents an error or failure case Right - Typically represents a success or normal case map - Transform the Right value, leave Left untouched chain - Apply a function that returns an Either to a Right value fold - Process both possibilities with separate functions Usage Example import Either from '../core/types/either.js'; // Parse a JSON string safely const parseJson = str => { try { return Either.Right(JSON.parse(str)); } catch (e) { return Either.Left(`Invalid JSON: ${e.message}`); } }; // Process user configuration const processConfig = configStr => parseJson(configStr) .map(config => ({ ...config, lastUpdated: new Date().toISOString() })) .fold( error => ({ error, valid: false }), config => ({ config, valid: true }) ); // Usage const validConfig = '{\"theme\":\"dark\",\"notifications\":true}'; const invalidConfig = '{theme:\"dark\",notifications:true}'; console.log(processConfig(validConfig)); // { config: { theme: 'dark', notifications: true, lastUpdated: '...' }, valid: true } console.log(processConfig(invalidConfig)); // { error: 'Invalid JSON: ...', valid: false } For complete details on the Either type, see the Either API Reference ."
  },
  {
    "title": "Effects - FlexNet JSX Framework",
    "path": "systems/effects.html",
    "content": "GitHub Starter Project Home / Systems / Effects Effect System Learn how to manage side effects in a functional way with FlexNet JSX. Introduction Side effects are an inevitable part of web applications — from fetching data and setting timers to manipulating the DOM. The challenge in functional programming is handling these side effects while maintaining the benefits of pure functions. FlexNet's Effect System provides a solution by: Isolating side effects from pure business logic Making effects composable and reusable Ensuring proper resource cleanup Providing a predictable way to test effects The Effect Model In FlexNet, an effect is represented as a function that: Takes configuration or dependencies as input Returns a function that performs the actual effect Optionally returns a cleanup function Effect Structure // Effect creator const myEffect = (config) => { // Returns the effect runner return (handlers) => { // Perform the effect const resource = performSideEffect(); // Return cleanup function return () => { // Clean up resources cleanupResource(resource); }; }; }; Creating Effects FlexNet provides a createEffect function to make it easier to define effects: import { createEffect } from './src/systems/effects/effect.js'; // Simple timer effect const timerEffect = (intervalMs) => createEffect(({ onTick }) => { const timerId = setInterval(() => { onTick(new Date()); }, intervalMs); // Return cleanup function return () => clearInterval(timerId); }); Running Effects To run an effect, use the runEffect function: import { runEffect } from './src/systems/effects/effect.js'; // Create the effect const effect = timerEffect(1000); // Run the effect with handlers const cleanup = runEffect(effect, { onTick: (date) => console.log('Tick:', date) }); // Later, when you want to clean up: cleanup(); Important Always store and call the cleanup function to prevent memory leaks, especially when creating effects in components that may unmount. Common Effect Patterns Fetch Data Effect A common use case is fetching data from an API: const fetchDataEffect = (url) => createEffect(({ onSuccess, onError, onLoading }) => { let isCancelled = false; const controller = new AbortController(); const signal = controller.signal; onLoading(true); fetch(url, { signal }) .then(response => { if (!response.ok) { throw new Error('Network response was not ok'); } return response.json(); }) .then(data => { if (!isCancelled) { onLoading(false); onSuccess(data); } }) .catch(error => { if (!isCancelled) { onLoading(false); onError(error); } }); return () => { isCancelled = true; controller.abort(); }; }); Local Storage Effect Persisting state to local storage: const localStorageEffect = (key, initialValue) => createEffect(({ onChange }) => { // Read from localStorage on initialization try { const item = window.localStorage.getItem(key); const value = item ? JSON.parse(item) : initialValue; onChange(value); } catch (error) { console.error('Error reading from localStorage:', error); onChange(initialValue); } // Set up listener for storage events (for multi-tab support) const handleStorage = (event) => { if (event.key === key) { try { const newValue = JSON.parse(event.newValue); onChange(newValue); } catch (error) { console.error('Error parsing localStorage value:', error); } } }; window.addEventListener('storage', handleStorage); // Return cleanup function return () => { window.removeEventListener('storage', handleStorage); }; }); Event Listener Effect Adding and removing DOM event listeners: const eventListenerEffect = (target, eventType) => createEffect(({ onEvent }) => { const handler = (event) => { onEvent(event); }; target.addEventListener(eventType, handler); return () => { target.removeEventListener(eventType, handler); }; }); Composing Effects One of the key advantages of FlexNet's effect system is the ability to compose effects together: import { composeEffects } from './src/systems/effects/effect.js'; // Simple logging effect const logEffect = (message) => createEffect(() => { console.log(`Effect started: ${message}`); return () => console.log(`Effect cleaned up: ${message}`); }); // Combine timer and logging const combinedEffect = composeEffects( timerEffect(1000), logEffect('Timer effect') ); // Run the combined effect const cleanup = runEffect(combinedEffect, { onTick: (date) => console.log('Tick:', date) }); // Cleanup will clean up both effects cleanup(); Effects with State Effects often need to interact with state. Here's a pattern for combining effects with the state system: import { createStore } from './src/systems/state/store.js'; import { createEffect, runEffect } from './src/systems/effects/effect.js'; // Create a store const userStore = createStore({ data: null, loading: false, error: null }); // Define state update functions const setLoading = loading => state => ({ ...state, loading, error: null }); const setData = data => state => ({ ...state, data, loading: false, error: null }); const setError = error => state => ({ ...state, error, loading: false }); // Create a fetch effect that updates state const fetchUserEffect = (userId) => createEffect(() => { userStore.update(setLoading(true)); fetch(`/api/users/${userId}`) .then(response => response.json()) .then(data => { userStore.update(setData(data)); }) .catch(error => { userStore.update(setError(error.message)); }); // No cleanup needed in this simple example return () => {}; }); Conditional Effects Sometimes you only want to run an effect under certain conditions: // Run effect only if condition is true const conditionalEffect = (condition, effect) => { if (condition) { return effect; } else { // Return a no-op effect return createEffect(() => () => {}); } }; // Example usage const effect = conditionalEffect( userId !== null, fetchUserEffect(userId) ); Testing Effects FlexNet's effect system makes it easier to test side effects: // Define a mock fetch function const mockFetch = (mockData) => { return () => Promise.resolve({ ok: true, json: () => Promise.resolve(mockData) }); }; // Test the fetch effect test('fetchUserEffect should call onSuccess with user data', async () => { // Setup const mockUser = { id: 1, name: 'Test User' }; const originalFetch = global.fetch; global.fetch = jest.fn().mockImplementation(mockFetch(mockUser)); // Create handlers with jest mocks const handlers = { onSuccess: jest.fn(), onError: jest.fn(), onLoading: jest.fn() }; // Run the effect const cleanup = runEffect(fetchUserEffect('/api/users/1'), handlers); // Wait for promises to resolve await new Promise(resolve => setTimeout(resolve, 0)); // Assertions expect(handlers.onLoading).toHaveBeenCalledWith(true); expect(handlers.onSuccess).toHaveBeenCalledWith(mockUser); expect(handlers.onError).not.toHaveBeenCalled(); // Cleanup cleanup(); global.fetch = originalFetch; }); Best Practices Effect Best Practices 1 Always Return a Cleanup Function Even if no cleanup is needed, return an empty function to maintain consistency. 2 Keep Effects Small and Focused Each effect should do one thing well, allowing for better composition and testing. 3 Handle Cancellation For async effects, properly handle cancellation to prevent race conditions. 4 Separate Effects from Business Logic Keep your core business logic pure and delegate side effects to the effect system. Complete Example Here's a complete example of a user data loader using the effect system: import { createElement, render } from './src/core/runtime/jsx.js'; import { createStore } from './src/systems/state/store.js'; import { createEffect, runEffect } from './src/systems/effects/effect.js'; import { Maybe } from './src/core/types/maybe.js'; // === State === const userStore = createStore({ data: Maybe.Nothing(), loading: false, error: Maybe.Nothing() }); // State update functions const setLoading = loading => state => ({ ...state, loading }); const setData = data => state => ({ ...state, data: Maybe.Just(data), loading: false, error: Maybe.Nothing() }); const setError = error => state => ({ ...state, error: Maybe.Just(error), loading: false }); // === Effects === const userFetchEffect = (userId) => createEffect(() => { userStore.update(setLoading(true)); const controller = new AbortController(); const signal = controller.signal; fetch(`/api/users/${userId}`, { signal }) .then(response => { if (!response.ok) { throw new Error(`HTTP error! status: ${response.status}`); } return response.json(); }) .then(data => { userStore.update(setData(data)); }) .catch(error => { if (error.name !== 'AbortError') { userStore.update(setError(error.message)); } }); return () => { controller.abort(); }; }); // === Components === const UserProfile = ({ userId }) => { // Run the effect when the component mounts const cleanup = runEffect(userFetchEffect(userId)); // Store cleanup for component unmount addEventListener('beforeunload', cleanup); return createElement('div', null, userStore.getState().loading && createElement('p', null, 'Loading...'), userStore.getState().error.map( err => createElement('p', { className: 'error' }, `Error: ${err}`) ).getOrElse(null), userStore.getState().data.map( user => createElement('div', null, createElement('h2', null, user.name), createElement('p', null, user.email), createElement('p', null, user.bio) ) ).getOrElse(null) ); }; // === Application Initialization === function init() { render( createElement(UserProfile, { userId: '123' }), document.getElementById('root') ); // Subscribe to state changes to re-render userStore.subscribe(() => { render( createElement(UserProfile, { userId: '123' }), document.getElementById('root') ); }); } document.addEventListener('DOMContentLoaded', init); API Reference createEffect Creates an effect from an effect function. Parameters effectFn - A function that performs the effect and returns a cleanup function Returns An effect object that can be passed to runEffect runEffect Executes an effect with the provided handlers. Parameters effect - An effect created with createEffect handlers - Object containing handler functions for effect events Returns A cleanup function that should be called when the effect is no longer needed composeEffects Combines multiple effects into a single effect. Parameters ...effects - One or more effects to compose together Returns A composed effect that runs all the provided effects and returns a function that cleans up all of them Next Steps State Management Learn how to use FlexNet's state management system. Render System Explore the rendering system in depth. Todo App Example See effects in action in a complete application. Maybe Type Learn about the Maybe type, often used with effects. Looking for more examples? Check out our Website Example to see how effects are used in a more complex application."
  },
  {
    "title": "Error Handling - FlexNet JSX Framework",
    "path": "systems/errors.html",
    "content": "GitHub Starter Project Home / Systems / Error Handling Error Handling FlexNet JSX provides a comprehensive, functional approach to error handling throughout your application. Functional Error Handling Philosophy FlexNet JSX takes a functional approach to error handling, based on these core principles: Core Principles Errors are values, not exceptions Error paths are explicit and type-safe Error handling is composable Errors are isolated and don't cause cascading failures Runtime exceptions are minimized by design Error Handling Types FlexNet JSX provides three core types for handling different error scenarios: Maybe For representing optional values that might be missing, but aren't errors. View Documentation → Either For representing computations that can either succeed or fail with an error value. View Documentation → Result For representing asynchronous operations that can succeed or fail with an error. View Documentation → When to Use Each Type Choosing the Right Type Type Use Case Example Maybe When a value might be absent, but that's not an error User profile that might not exist yet Either When an operation can fail with a specific error value Form validation with validation errors Result For async operations that can succeed or fail API calls, file operations Handling Errors with Maybe The Maybe type represents optional values that might be absent. It's not for errors per se, but for handling the absence of a value gracefully. import { Maybe } from './src/core/types/maybe.js'; // Creating Maybe values const maybeUser = Maybe.fromNullable(getUserFromStorage()); // Handling Maybe values with pattern matching const greeting = maybeUser.match({ Just: user => `Hello, ${user.name}!`, Nothing: () => 'Hello, Guest!' }); // Transforming Maybe values const maybeUsername = maybeUser .map(user => user.username) .getOrElse('anonymous'); // Rendering UI with Maybe const UserProfile = ({ userMaybe }) => createElement('div', { className: 'profile' }, userMaybe.match({ Just: user => [ createElement('h2', null, user.name), createElement('p', null, user.email) ], Nothing: () => createElement('p', null, 'Please log in to view your profile') }) ); Handling Errors with Either The Either type represents computations that can either succeed with a right value or fail with a left value (typically an error). import { Either } from './src/core/types/either.js'; // Form validation using Either const validateEmail = email => { if (!email) { return Either.Left('Email is required'); } if (!/\\S+@\\S+\\.\\S+/.test(email)) { return Either.Left('Email is invalid'); } return Either.Right(email); }; const validatePassword = password => { if (!password) { return Either.Left('Password is required'); } if (password.length { return validateEmail(email).chain(validEmail => validatePassword(password).map(validPassword => ({ email: validEmail, password: validPassword })) ); }; // Using the validation const loginResult = validateLogin(formData.email, formData.password); // Handling the result with pattern matching loginResult.match({ Right: credentials => loginUser(credentials), Left: error => showError(error) }); Handling Errors with Result The Result type is specifically designed for asynchronous operations that can either succeed or fail with an error. import { Result } from './src/core/types/result.js'; // Fetching data with Result const fetchUser = userId => { return fetch(`/api/users/${userId}`) .then(response => { if (!response.ok) { return Result.Error(`Failed to fetch user: ${response.status}`); } return response.json().then(data => Result.Ok(data)); }) .catch(error => Result.Error(`Network error: ${error.message}`)); }; // Using the Result fetchUser(123) .then(result => result.match({ Ok: user => { // Handle success displayUserProfile(user); }, Error: error => { // Handle error showErrorMessage(error); } })); // Convert try/catch to Result const parseJSON = jsonString => { return Result.try(() => JSON.parse(jsonString)); }; // Using try/catch with Result const parsedData = parseJSON('{\"name\": \"John\"}').match({ Ok: data => data, Error: error => ({ name: 'Unknown' }) }); Error Boundaries in UI FlexNet JSX provides a way to create error boundaries that catch and handle errors in the UI rendering process: import { createElement } from './src/core/runtime/jsx.js'; import { Result } from './src/core/types/result.js'; // Error boundary component const ErrorBoundary = ({ children, fallback }) => { try { // Attempt to render children return children; } catch (error) { // If rendering fails, render the fallback return typeof fallback === 'function' ? fallback(error) : fallback; } }; // Using Result for safer boundaries const SafeComponent = ({ component, props, fallback }) => { const renderResult = Result.try(() => component(props)); return renderResult.match({ Ok: rendered => rendered, Error: error => fallback(error) }); }; // Usage const App = () => createElement(ErrorBoundary, { fallback: error => createElement('div', { className: 'error-container' }, createElement('h2', null, 'Something went wrong'), createElement('p', null, error.message), createElement('button', { onClick: () => window.location.reload() }, 'Refresh the page') ) }, createElement(UserDashboard, { userId: currentUserId }) ); Combining Error Handling Types FlexNet JSX allows you to combine different error handling types for more complex scenarios: import { Maybe } from './src/core/types/maybe.js'; import { Either } from './src/core/types/either.js'; import { Result } from './src/core/types/result.js'; // Get user from session (Maybe) const maybeUser = Maybe.fromNullable(session.user); // Validate user permissions (Either) const checkPermissions = user => { if (!user.permissions.includes('admin')) { return Either.Left('User does not have admin permissions'); } return Either.Right(user); }; // Fetch data from API (Result) const fetchAdminData = user => { return fetch(`/api/admin/data?token=${user.token}`) .then(response => { if (!response.ok) { return Result.Error(`API error: ${response.status}`); } return response.json().then(data => Result.Ok(data)); }) .catch(error => Result.Error(`Network error: ${error.message}`)); }; // Combining all three types const getAdminData = () => { // Convert Maybe to Either const userEither = maybeUser.toEither('User not logged in'); // Chain with permission check const permissionResult = userEither.chain(checkPermissions); // Convert Either to Promise for async operation return permissionResult.match({ Right: user => fetchAdminData(user), Left: error => Promise.resolve(Result.Error(error)) }); }; // Usage getAdminData().then(result => { result.match({ Ok: data => renderAdminDashboard(data), Error: error => showErrorMessage(error) }); }); Logging and Monitoring Errors FlexNet JSX provides utilities for logging and monitoring errors in a functional way: import { Result } from './src/core/types/result.js'; import { logger } from './src/core/runtime/logger.js'; // Enhanced Result with logging const fetchWithLogging = url => { logger.info(`Fetching data from ${url}`); return fetch(url) .then(response => { if (!response.ok) { const error = `API error: ${response.status}`; logger.error(error, { url, status: response.status }); return Result.Error(error); } return response.json() .then(data => { logger.info(`Successfully fetched data from ${url}`); return Result.Ok(data); }); }) .catch(error => { logger.error(`Network error: ${error.message}`, { url, error }); return Result.Error(`Network error: ${error.message}`); }); }; // Utility for tapping into Either for side effects like logging const tapEither = (either, leftFn, rightFn) => { either.match({ Left: value => { leftFn(value); return either; }, Right: value => { rightFn(value); return either; } }); return either; }; // Usage with logging const validationResult = validateUserData(userData); tapEither( validationResult, error => logger.warn(`Validation failed: ${error}`), data => logger.info('Validation succeeded') ); Global Error Handling For handling uncaught errors at the application level, FlexNet provides a global error handling system: import { setGlobalErrorHandler } from './src/systems/errors/global.js'; import { logger } from './src/core/runtime/logger.js'; // Set up global error handling setGlobalErrorHandler({ onError: (error, info) => { // Log the error logger.error('Unhandled error', { error, info }); // Display error UI renderErrorOverlay({ message: 'An unexpected error occurred', details: process.env.NODE_ENV === 'development' ? error.stack : null, onReload: () => window.location.reload() }); // Report to error tracking service if (errorTrackingService) { errorTrackingService.captureException(error, { extra: info }); } }, onUnhandledRejection: (reason, promise) => { logger.error('Unhandled promise rejection', { reason, promise }); // Similar handling as onError } }); Best Practices Use the appropriate type (Maybe, Either, Result) for each error scenario Always handle all possible cases in pattern matching Log errors with useful context information Provide meaningful error messages to users Use error boundaries to prevent error propagation in the UI Avoid using try/catch directly; prefer Result.try for wrapping exceptions Next Steps Maybe API Learn about the Maybe type for handling optional values. Either API Explore the Either type for handling computational errors. Result API Understand the Result type for handling asynchronous errors. Todo App Example See error handling in action in a complete application."
  },
  {
    "title": "Events System - FlexNet JSX Framework",
    "path": "systems/events.html",
    "content": "GitHub Starter Project Home / Systems / Events Events System The FlexNet JSX events system provides a functional approach to handling DOM events, ensuring clean separation between UI and behavior. Event Handling Principles The FlexNet JSX events system is built on the following core principles: Core Principles Events are handled using pure functions Event handlers don't mutate state directly Side effects are isolated and managed separately Event flow follows a unidirectional data flow pattern Events are composable using functional composition Basic Event Handling In FlexNet JSX, event handlers are attached to elements as props using the standard camelCase naming convention: import { createElement } from './src/core/runtime/jsx.js'; // Simple event handler const handleClick = (event) => { console.log('Button clicked!', event); }; // Creating an element with an event handler const button = createElement('button', { onClick: handleClick }, 'Click Me'); // Using in a component const Button = ({ onClick, label }) => createElement('button', { onClick, className: 'btn' }, label); Supported Events FlexNet JSX supports all standard DOM events, including: Mouse Events onClick onMouseDown onMouseUp onMouseEnter onMouseLeave onMouseMove onContextMenu Keyboard Events onKeyDown onKeyUp onKeyPress Form Events onChange onInput onSubmit onReset onFocus onBlur Functional Event Handling FlexNet JSX encourages a functional approach to event handling, with clear separation between: Event capture (handling the DOM event) Data transformation (pure functions that process the event data) State updates (applying the transformed data to the application state) Side effects (performing any necessary side effects) Event Composition One of the powerful features of FlexNet JSX is the ability to compose event handlers using functional composition: import { compose } from './src/core/runtime/runtime.js'; import { createElement } from './src/core/runtime/jsx.js'; // Event extraction function const getInputValue = event => event.target.value; // Data transformation function const sanitizeInput = value => value.trim(); const validateEmail = email => { const isValid = /\\S+@\\S+\\.\\S+/.test(email); return { email, isValid }; }; // Composed event handler const handleEmailChange = compose( validateEmail, sanitizeInput, getInputValue ); // Usage in a component const EmailInput = ({ onEmailChange }) => createElement('input', { type: 'email', placeholder: 'Enter your email', onChange: event => { const result = handleEmailChange(event); onEmailChange(result); } }); Preventing Default Behavior To prevent the default browser behavior for an event, you can use the preventDefault method: // Form submission handler const handleSubmit = event => { // Prevent the browser from submitting the form event.preventDefault(); // Process the form data const formData = new FormData(event.target); const data = Object.fromEntries(formData.entries()); // Submit the data programmatically submitFormData(data); }; // Usage in a form component const Form = ({ onSubmit }) => createElement('form', { onSubmit: handleSubmit }, // Form elements ); Integrating Events with State FlexNet JSX provides a clean way to integrate event handling with state management: import { createElement, render } from './src/core/runtime/jsx.js'; import { createStore } from './src/systems/state/store.js'; // Create a store for the form state const formStore = createStore({ email: '', isEmailValid: false, password: '', isPasswordValid: false, submitted: false }); // Event handlers const handleEmailChange = event => { const email = event.target.value; const isEmailValid = /\\S+@\\S+\\.\\S+/.test(email); // Update state with the transformed data formStore.update(state => ({ ...state, email, isEmailValid })); }; const handlePasswordChange = event => { const password = event.target.value; const isPasswordValid = password.length >= 8; // Update state with the transformed data formStore.update(state => ({ ...state, password, isPasswordValid })); }; const handleSubmit = event => { event.preventDefault(); // Update state to indicate submission formStore.update(state => ({ ...state, submitted: true })); // Only perform the submit action if the form is valid if (formStore.getState().isEmailValid && formStore.getState().isPasswordValid) { submitForm(formStore.getState()); } }; // Form component const LoginForm = ({ email, isEmailValid, password, isPasswordValid, submitted }) => createElement('form', { onSubmit: handleSubmit, className: 'login-form' }, createElement('div', { className: 'form-group' }, createElement('label', null, 'Email'), createElement('input', { type: 'email', value: email, onChange: handleEmailChange, className: isEmailValid ? 'valid' : (submitted ? 'invalid' : '') }), !isEmailValid && submitted && createElement('p', { className: 'error' }, 'Please enter a valid email') ), createElement('div', { className: 'form-group' }, createElement('label', null, 'Password'), createElement('input', { type: 'password', value: password, onChange: handlePasswordChange, className: isPasswordValid ? 'valid' : (submitted ? 'invalid' : '') }), !isPasswordValid && submitted && createElement('p', { className: 'error' }, 'Password must be at least 8 characters') ), createElement('button', { type: 'submit' }, 'Log In') ); // Render the form with state formStore.subscribe(state => { render( createElement(LoginForm, state), document.getElementById('login-container') ); }); Event Delegation FlexNet JSX uses event delegation under the hood for better performance. This means that event listeners are attached to a common ancestor rather than to each individual element. Benefits of Event Delegation Advantages Reduces memory usage by having fewer event listeners Improves performance for large lists or tables Handles dynamically added elements automatically Simplifies event management Example: Event Delegation for Lists import { createElement } from './src/core/runtime/jsx.js'; // Todo list with delegated event handling const TodoList = ({ todos, onToggle, onDelete }) => createElement('ul', { className: 'todo-list', // Event handlers on the container element onClick: event => { const todoId = event.target.closest('li')?.dataset.id; if (!todoId) return; // Check which action was clicked if (event.target.className === 'toggle') { onToggle(todoId); } else if (event.target.className === 'delete') { onDelete(todoId); } } }, todos.map(todo => createElement('li', { key: todo.id, 'data-id': todo.id, className: todo.completed ? 'completed' : '' }, createElement('span', { className: 'toggle' }, todo.completed ? '✅' : '◻️' ), createElement('span', { className: 'text' }, todo.text), createElement('button', { className: 'delete' }, '🗑️') ) ) ); Custom Events FlexNet JSX allows you to work with custom events for more specialized communication between components: import { createElement } from './src/core/runtime/jsx.js'; // Creating a custom event const createCustomEvent = (name, detail) => { return new CustomEvent(name, { detail, bubbles: true, cancelable: true }); }; // Component that dispatches a custom event const ProductCard = ({ product }) => createElement('div', { className: 'product-card', onClick: event => { // Create and dispatch a custom event const customEvent = createCustomEvent('product-selected', { productId: product.id, productName: product.name, timestamp: new Date() }); event.target.dispatchEvent(customEvent); } }, createElement('h3', null, product.name), createElement('p', null, product.description), createElement('span', { className: 'price' }, `$${product.price.toFixed(2)}`) ); // Listening for custom events document.addEventListener('product-selected', event => { console.log('Product selected:', event.detail); // Handle the product selection }); Advanced Event Techniques Debouncing and Throttling For events that fire frequently (like scrolling or resizing), it's often useful to debounce or throttle the event handlers: import { debounce, throttle } from './src/core/runtime/runtime.js'; import { createElement } from './src/core/runtime/jsx.js'; // Original event handler const handleSearch = event => { const query = event.target.value; performSearch(query); }; // Debounced version (only executes after 300ms of inactivity) const debouncedSearch = debounce(handleSearch, 300); // Throttled version (executes at most once every 200ms) const throttledScroll = throttle(() => { console.log('Scroll position:', window.scrollY); }, 200); // Usage in components const SearchInput = () => createElement('input', { type: 'text', placeholder: 'Search...', onChange: debouncedSearch }); // Attach the throttled scroll handler to the window window.addEventListener('scroll', throttledScroll); Using Either for Error Handling FlexNet's Either type can be used for handling errors in event handlers: import { Either } from './src/core/types/either.js'; import { createElement } from './src/core/runtime/jsx.js'; // Parse and validate form data const parseFormData = formElement => { try { const formData = new FormData(formElement); const data = Object.fromEntries(formData.entries()); // Validate the data if (!data.username) { return Either.Left(new Error('Username is required')); } if (!data.email || !/\\S+@\\S+\\.\\S+/.test(data.email)) { return Either.Left(new Error('Valid email is required')); } // Return the valid data return Either.Right(data); } catch (error) { return Either.Left(error); } }; // Form submission handler with Either const handleSubmit = event => { event.preventDefault(); parseFormData(event.target).match({ Right: data => { // Success path: Submit the valid data submitUserData(data) .then(response => showSuccessMessage(response)) .catch(error => showErrorMessage(error)); }, Left: error => { // Error path: Display the validation error showErrorMessage(error.message); } }); }; // Form component const RegistrationForm = () => createElement('form', { onSubmit: handleSubmit, className: 'registration-form' }, // Form fields ); Best Practices Keep event handlers pure and focused on a single responsibility Use composition to build complex event handling logic Separate event capturing from state updates Use debounce or throttle for high-frequency events Handle errors gracefully using functional types like Either or Result Prefer event delegation for lists and tables Next Steps Effects System Learn how to handle side effects that result from events. Error Handling Explore comprehensive error handling strategies."
  },
  {
    "title": "Render System - FlexNet JSX Framework",
    "path": "systems/render.html",
    "content": "GitHub Starter Project Home / Systems / Render Render System The FlexNet JSX render system efficiently translates virtual DOM elements into real DOM nodes while maintaining purity and immutability. Overview The render system in FlexNet JSX is responsible for converting the virtual DOM elements created by the JSX runtime into actual DOM elements that can be displayed in the browser. The system is designed with functional programming principles in mind, ensuring that rendering operations are pure, predictable, and efficient. Key Features Pure functional rendering with no side effects Efficient diffing algorithm for minimal DOM updates Immutable virtual DOM representation Component-based architecture Support for functional components Basic Rendering The core of the render system is the render function, which takes a virtual DOM element and a DOM container, and mounts the element into the container. import { createElement, render } from './src/core/runtime/jsx.js'; // Create a virtual DOM element const element = createElement('div', { className: 'greeting' }, 'Hello, World!'); // Render it to the DOM render(element, document.getElementById('root')); Functional Components FlexNet supports functional components, which are functions that accept props and return virtual DOM elements: // Define a functional component const Greeting = ({ name }) => createElement('div', { className: 'greeting' }, `Hello, ${name}!` ); // Use the component const element = createElement(Greeting, { name: 'World' }); // Render it render(element, document.getElementById('root')); Virtual DOM FlexNet JSX uses a virtual DOM approach to optimize rendering performance. The virtual DOM is a lightweight, immutable representation of the actual DOM structure. Virtual DOM Structure Each virtual DOM element has the following structure: // Basic structure of a virtual DOM element { type: 'div', // String for HTML elements, Function for components props: { className: 'container', // Regular DOM properties children: [...] // Child elements } } Diffing Algorithm When re-rendering, FlexNet compares the new virtual DOM with the previous one to determine the minimal set of changes needed to update the actual DOM. How Diffing Works Compare element types (tag names or component functions) If types are different, replace the entire subtree If types are the same, update only the changed properties Recursively diff the children Apply the minimal set of changes to the DOM Rendering Process The rendering process in FlexNet JSX follows these steps: Element Creation Create virtual DOM elements using the createElement function or JSX syntax. Component Resolution For component elements, call the component function to get the rendered elements. Tree Building Build a complete virtual DOM tree by recursively resolving all components. Diffing Compare the new virtual DOM tree with the previous one. Patch Generation Generate a set of patches (operations) needed to update the DOM. DOM Updates Apply the patches to the actual DOM in a single batch. Event Binding Attach event handlers to the rendered elements. Example: Rendering with State Updates import { createElement, render } from './src/core/runtime/jsx.js'; import { createStore } from './src/systems/state/store.js'; // Create a store with initial state const store = createStore({ count: 0 }); // Define a counter component const Counter = ({ count, onIncrement }) => createElement('div', null, createElement('h2', null, `Count: ${count}`), createElement('button', { onClick: onIncrement }, 'Increment') ); // Subscribe to state changes store.subscribe(state => { // Render with new state when it changes render( createElement(Counter, { count: state.count, onIncrement: () => store.update(s => ({ count: s.count + 1 })) }), document.getElementById('root') ); }); Render API The FlexNet JSX render system provides the following core functions: render The primary function for rendering elements to the DOM. /** * Render a virtual DOM element to a DOM container * @param {VNode} element - The virtual DOM element to render * @param {HTMLElement} container - The DOM container to render into * @returns {void} */ function render(element, container) { // Implementation details } createElement Creates virtual DOM elements that can be rendered. /** * Create a virtual DOM element * @param {string|function} type - The element type (tag name or component function) * @param {object} props - The element properties * @param {...any} children - The element children * @returns {VNode} A virtual DOM node */ function createElement(type, props, ...children) { // Implementation details } createFragment Creates a fragment that can hold multiple elements without adding extra DOM nodes. /** * Create a virtual DOM fragment * @param {Array} children - The fragment children * @returns {VNode} A virtual DOM fragment */ function createFragment(children) { // Implementation details } Advanced Rendering Techniques FlexNet JSX supports several advanced rendering techniques: Conditional Rendering import { createElement } from './src/core/runtime/jsx.js'; import { Maybe } from './src/core/types/maybe.js'; // Using Maybe for conditional rendering const UserProfile = ({ user }) => createElement('div', { className: 'profile' }, // Render user info if user exists, otherwise render a login prompt Maybe.fromNullable(user).match({ Just: (userData) => [ createElement('h2', null, userData.name), createElement('p', null, userData.email) ], Nothing: () => createElement('button', { onClick: login }, 'Log In') }) ); List Rendering import { createElement } from './src/core/runtime/jsx.js'; // Rendering lists with proper keys const TodoList = ({ todos, onToggle }) => createElement('ul', { className: 'todo-list' }, todos.map(todo => createElement('li', { key: todo.id, // Unique key for efficient updates className: todo.completed ? 'completed' : '' }, createElement('input', { type: 'checkbox', checked: todo.completed, onChange: () => onToggle(todo.id) }), createElement('span', null, todo.text) ) ) ); Error Boundaries FlexNet provides a way to handle rendering errors gracefully: import { createElement } from './src/core/runtime/jsx.js'; import { Result } from './src/core/types/result.js'; // Error boundary component const ErrorBoundary = ({ children, fallback }) => { // Try to render children safely const renderResult = Result.try(() => children); // Return children or fallback based on result return renderResult.match({ Ok: renderedChildren => renderedChildren, Error: error => typeof fallback === 'function' ? fallback(error) : fallback }); }; // Usage const App = () => createElement(ErrorBoundary, { fallback: (error) => createElement('div', { className: 'error' }, `Something went wrong: ${error.message}` ) }, createElement(UserProfile, { user: currentUser }) ); Optimizing Render Performance To optimize rendering performance in FlexNet JSX, consider the following techniques: Memoization Use the memoize function to prevent unnecessary re-renders of expensive components. Keys Always use unique keys when rendering lists to help the diffing algorithm identify changes efficiently. Granular Components Break UI into smaller, focused components to minimize the impact of state changes. Avoid Deep Nesting Excessively deep component hierarchies can slow down the diffing process. Example: Memoized Component import { createElement } from './src/core/runtime/jsx.js'; import { memoize } from './src/core/runtime/runtime.js'; // Expensive component that shouldn't re-render unless props change const ExpensiveComponent = ({ data }) => { // Complex processing... const processedData = someExpensiveCalculation(data); return createElement('div', null, // Render processed data ); }; // Memoized version that only re-renders when data actually changes const MemoizedExpensiveComponent = memoize(ExpensiveComponent, (prevProps, nextProps) => { // Custom comparison function return JSON.stringify(prevProps.data) === JSON.stringify(nextProps.data); } ); Tip When working with the FlexNet JSX render system, embrace the functional programming paradigm. Use pure functions, immutable data structures, and composition to create predictable, maintainable, and efficient UIs. Next Steps Events System Learn how FlexNet handles DOM events in a functional way. JSX API Reference Explore the complete API reference for the JSX runtime."
  },
  {
    "title": "State Management - FlexNet JSX Framework",
    "path": "systems/state.html",
    "content": "GitHub Starter Project Home / Systems / State Management State Management FlexNet JSX implements a functional, immutable approach to state management that provides predictability, testability, and maintainability. This document explains the core principles, implementation, and best practices for state management in FlexNet. Important FlexNet's state management follows strict functional programming principles with immutable state transitions and a unidirectional data flow. Core Principles Immutability: State is never modified directly; each state change creates a new state object. Unidirectional Flow: Data flows in one direction, making the application state predictable. Pure Functions: State transformations are performed by pure functions with no side effects. Centralized Store: A single source of truth for application state with controlled access. The Store At the heart of FlexNet's state management is the store, a functional implementation that maintains application state and notifies subscribers of changes. Basic Store Implementation // src/systems/state/store.js const createStore = (initialState) => { const subscribers = new Set(); let state = initialState; return { getState: () => state, update: (updater) => { state = updater(state); subscribers.forEach(subscriber => subscriber(state)); return state; }, subscribe: (subscriber) => { subscribers.add(subscriber); // Return unsubscribe function return () => subscribers.delete(subscriber); } }; }; Key Concepts getState - Returns the current state update - Updates the state using a pure function updater subscribe - Registers a callback to be notified of state changes Usage Example import { createStore } from './systems/state/store.js'; import Maybe from './core/types/maybe.js'; // Create a store with initial state const store = createStore(Maybe.Just(0)); // Update the state store.update(count => Maybe.Just(count.value + 1)); // Subscribe to state changes const unsubscribe = store.subscribe(state => { console.log('State updated:', state.value); }); // Later, unsubscribe when done unsubscribe(); Immutable State Updates All state updates in FlexNet are performed using pure functions that produce a new state object instead of modifying the existing one. Simple Updates // Creating a counter store const counterStore = createStore(Maybe.Just(0)); // Increment function (pure) const increment = count => Maybe.Just(count.value + 1); // Decrement function (pure) const decrement = count => Maybe.Just(count.value - 1); // Applying updates counterStore.update(increment); counterStore.update(decrement); Complex State Updates // Creating a todo list store const todosStore = createStore(Maybe.Just([])); // Add todo (pure function) const addTodo = (text) => (todos) => Maybe.Just([ ...todos.value, { id: Date.now(), text, completed: false } ]); // Toggle todo completion (pure function) const toggleTodo = (id) => (todos) => Maybe.Just( todos.value.map(todo => todo.id === id ? { ...todo, completed: !todo.completed } : todo ) ); // Remove todo (pure function) const removeTodo = (id) => (todos) => Maybe.Just( todos.value.filter(todo => todo.id !== id) ); // Applying updates todosStore.update(addTodo('Learn FlexNet')); todosStore.update(addTodo('Build an app')); todosStore.update(toggleTodo(1234567890)); Integration with FlexNet Types FlexNet's state management integrates seamlessly with the type system to provide type-safe state operations. Using Maybe for Optional State // User profile store with Maybe for handling loading/not found states const userProfileStore = createStore(Maybe.Nothing()); // Load user profile const loadUserProfile = (userId) => { // Simulate API call fetchUserProfile(userId) .then(profile => { userProfileStore.update(() => Maybe.Just(profile)); }) .catch(error => { console.error('Failed to load profile:', error); // Keep state as Nothing }); }; // Get user display name safely const getUserDisplayName = () => { const profileState = userProfileStore.getState(); return profileState .chain(profile => Maybe.fromNullable(profile.name)) .getOrElse('Anonymous'); }; Using Either for Error Handling import { createStore } from './systems/state/store.js'; import { Either } from './core/types/either.js'; // Store for handling form data with validation const formStore = createStore( Either.Right({ email: '', password: '' }) ); // Validate email and update state const updateEmail = (email) => { if (!email) { formStore.update(() => Either.Left('Email is required')); } else if (!/\\S+@\\S+\\.\\S+/.test(email)) { formStore.update(() => Either.Left('Email is invalid')); } else { formStore.update(state => state.map(s => ({ ...s, email })) ); } }; // Handle form submission const submitForm = () => { formStore.getState().fold( error => { // Show error message console.error('Form has errors:', error); }, data => { // Submit data console.log('Submitting data:', data); } ); };"
  },
  {
    "title": "Counter Example - FlexNet JSX Framework",
    "path": "examples/counter.html",
    "content": "GitHub Starter Project Home / Examples / Counter Counter Example The counter example is a classic way to demonstrate basic state management and UI updates. This example will walk you through building a simple counter application using FlexNet JSX's functional approach. Note This example showcases FlexNet's core principles of functional programming, immutable state, and pure functions. What We'll Build We'll create a counter with increment and decrement buttons: Counter: 0 - + Project Structure Our counter example will have the following file structure: counter-example/ ├── src/ │ ├── core/ │ │ ├── types/ │ │ │ └── maybe.js │ │ └── functions/ │ │ └── composition.js │ ├── systems/ │ │ └── state/ │ │ └── store.js │ └── features/ │ └── counter/ │ ├── functions.js │ └── index.js └── index.html Implementation Step 1: Create the Core Types First, let's implement the Maybe type for safe state handling: // src/core/types/maybe.js const Maybe = { Just: value => ({ type: 'Just', value, map: fn => Maybe.Just(fn(value)), chain: fn => fn(value), getOrElse: defaultValue => value }), Nothing: () => ({ type: 'Nothing', map: fn => Maybe.Nothing(), chain: fn => Maybe.Nothing(), getOrElse: defaultValue => defaultValue }), fromNullable: value => value != null ? Maybe.Just(value) : Maybe.Nothing(), map: fn => maybe => maybe.type === 'Just' ? Maybe.Just(fn(maybe.value)) : Maybe.Nothing(), chain: fn => maybe => maybe.type === 'Just' ? fn(maybe.value) : Maybe.Nothing(), getOrElse: defaultValue => maybe => maybe.type === 'Just' ? maybe.value : defaultValue }; export default Maybe; Step 2: Create Function Composition Utilities // src/core/functions/composition.js export const compose = (...fns) => x => fns.reduceRight((y, f) => f(y), x); export const pipe = (...fns) => x => fns.reduce((y, f) => f(y), x); export const curry = fn => (...args) => args.length >= fn.length ? fn(...args) : curry(fn.bind(null, ...args)); Step 3: Implement the Store // src/systems/state/store.js const createStore = (initialState) => { const subscribers = new Set(); let state = initialState; return { getState: () => state, update: (updater) => { state = updater(state); subscribers.forEach(subscriber => subscriber(state)); return state; }, subscribe: (subscriber) => { subscribers.add(subscriber); // Return unsubscribe function return () => subscribers.delete(subscriber); } }; }; export default createStore; Step 4: Create Counter Functions // src/features/counter/functions.js import Maybe from '../../core/types/maybe.js'; // Pure function to increment counter export const increment = count => Maybe.Just(count.value + 1); // Pure function to decrement counter export const decrement = count => Maybe.Just(count.value - 1); // Pure function to update counter with validation export const validateAndUpdate = (count, operation) => { const result = operation(count); // Ensure counter doesn't go below 0 (optional validation) if (result.value Step 5: Implement the Counter Component // src/features/counter/index.js import createStore from '../../systems/state/store.js'; import Maybe from '../../core/types/maybe.js'; import { increment, decrement, validateAndUpdate } from './functions.js'; // Create a store with initial count of 0 const counterStore = createStore(Maybe.Just(0)); // Create DOM elements for the counter const createCounter = () => { // Create container const container = document.createElement('div'); container.className = 'counter-container'; // Create heading const heading = document.createElement('h2'); heading.textContent = 'Counter: '; const countDisplay = document.createElement('span'); countDisplay.id = 'count-display'; countDisplay.textContent = counterStore.getState().value; heading.appendChild(countDisplay); // Create button container const buttonContainer = document.createElement('div'); buttonContainer.className = 'button-container'; // Create decrement button const decrementButton = document.createElement('button'); decrementButton.textContent = '-'; decrementButton.addEventListener('click', () => { counterStore.update(count => validateAndUpdate(count, decrement)); }); // Create increment button const incrementButton = document.createElement('button'); incrementButton.textContent = '+'; incrementButton.addEventListener('click', () => { counterStore.update(count => validateAndUpdate(count, increment)); }); buttonContainer.appendChild(decrementButton); buttonContainer.appendChild(incrementButton); container.appendChild(heading); container.appendChild(buttonContainer); return container; }; // Update UI on state change const updateUI = () => { const countDisplay = document.getElementById('count-display'); if (countDisplay) { countDisplay.textContent = counterStore.getState().value; } }; // Subscribe to store changes counterStore.subscribe(updateUI); // Mount the component to the DOM document.addEventListener('DOMContentLoaded', () => { const root = document.getElementById('root'); if (root) { root.appendChild(createCounter()); } });"
  },
  {
    "title": "Todo App Example - FlexNet JSX Framework",
    "path": "examples/todo.html",
    "content": "GitHub Starter Project Home / Examples / Todo App Todo App Example This example demonstrates how to build a complete Todo application using FlexNet JSX. It showcases state management, event handling, functional composition, and immutability. You can find the complete source code for this example in the GitHub repository . Live Demo Todo App Preview Open in new window Project Structure The Todo app is organized with a clear separation of concerns, following functional programming principles: todo/ ├── index.html ├── src/ │ ├── components/ │ │ ├── App.js │ │ ├── TodoForm.js │ │ ├── TodoItem.js │ │ └── TodoList.js │ ├── store/ │ │ ├── todoStore.js │ │ └── actions.js │ ├── types/ │ │ └── TodoTypes.js │ ├── utils/ │ │ └── uuid.js │ └── index.js └── styles.css State Management The app uses FlexNet's immutable store pattern for state management. Here's how the Todo store is implemented: // src/store/todoStore.js import { createStore } from '../../../src/systems/state/store.js'; import { Maybe } from '../../../src/core/types/maybe.js'; // Initial state with empty todos array const initialState = Maybe.Just({ todos: [], filter: 'all' // 'all', 'active', 'completed' }); // Create the immutable store export const todoStore = createStore(initialState); // Selectors (pure functions to derive data from state) export const selectors = { getAllTodos: state => state.todos, getFilteredTodos: state => { const { todos, filter } = state; switch(filter) { case 'active': return todos.filter(todo => !todo.completed); case 'completed': return todos.filter(todo => todo.completed); default: return todos; } }, getActiveCount: state => state.todos.filter(todo => !todo.completed).length, getCurrentFilter: state => state.filter }; Todo Actions Actions are pure functions that take the current state and return a new state: // src/store/actions.js import { Maybe } from '../../../src/core/types/maybe.js'; import { generateId } from '../utils/uuid.js'; // Pure action creators that return state transformation functions export const actions = { // Add a new todo item addTodo: text => state => Maybe.Just({ ...state, todos: [ ...state.todos, { id: generateId(), text, completed: false } ] }), // Toggle a todo's completed status toggleTodo: id => state => Maybe.Just({ ...state, todos: state.todos.map(todo => todo.id === id ? { ...todo, completed: !todo.completed } : todo ) }), // Remove a todo item removeTodo: id => state => Maybe.Just({ ...state, todos: state.todos.filter(todo => todo.id !== id) }), // Update a todo's text updateTodoText: (id, text) => state => Maybe.Just({ ...state, todos: state.todos.map(todo => todo.id === id ? { ...todo, text } : todo ) }), // Clear all completed todos clearCompleted: () => state => Maybe.Just({ ...state, todos: state.todos.filter(todo => !todo.completed) }), // Set the current filter setFilter: filter => state => Maybe.Just({ ...state, filter }) }; Components Let's look at the key components of our Todo app: TodoItem Component // src/components/TodoItem.js import { createElement } from '../../../src/core/runtime/jsx.js'; import { compose } from '../../../src/core/runtime/runtime.js'; // TodoItem is a pure functional component const TodoItem = ({ todo, onToggle, onRemove, onUpdate }) => { const handleDoubleClick = (e) => { const text = prompt('Edit todo:', todo.text); if (text !== null && text.trim() !== '') { onUpdate(todo.id, text); } }; return createElement('li', { className: `todo-item ${todo.completed ? 'completed' : ''}`, 'data-id': todo.id }, createElement('div', { className: 'view' }, createElement('input', { type: 'checkbox', className: 'toggle', checked: todo.completed, onChange: () => onToggle(todo.id) }), createElement('label', { onDblClick: handleDoubleClick }, todo.text), createElement('button', { className: 'destroy', onClick: () => onRemove(todo.id) }) ) ); }; export default TodoItem; TodoList Component // src/components/TodoList.js import { createElement } from '../../../src/core/runtime/jsx.js'; import TodoItem from './TodoItem.js'; const TodoList = ({ todos, onToggle, onRemove, onUpdate }) => { return createElement('ul', { className: 'todo-list' }, todos.map(todo => createElement(TodoItem, { key: todo.id, todo, onToggle, onRemove, onUpdate }) ) ); }; export default TodoList; TodoForm Component // src/components/TodoForm.js import { createElement } from '../../../src/core/runtime/jsx.js'; import { compose } from '../../../src/core/runtime/runtime.js'; const TodoForm = ({ onAdd }) => { const handleSubmit = (e) => { e.preventDefault(); const input = e.target.elements.newTodo; const text = input.value.trim(); if (text) { onAdd(text); input.value = ''; } }; return createElement('form', { className: 'todo-form', onSubmit: handleSubmit }, createElement('input', { className: 'new-todo', name: 'newTodo', placeholder: 'What needs to be done?', autoFocus: true }) ); }; export default TodoForm; Main App Component // src/components/App.js import { createElement } from '../../../src/core/runtime/jsx.js'; import { compose } from '../../../src/core/runtime/runtime.js'; import TodoForm from './TodoForm.js'; import TodoList from './TodoList.js'; import { actions } from '../store/actions.js'; import { todoStore, selectors } from '../store/todoStore.js'; const App = ({ state, dispatch }) => { const todos = selectors.getFilteredTodos(state); const activeCount = selectors.getActiveCount(state); const currentFilter = selectors.getCurrentFilter(state); // Event handlers use composition to combine actions with dispatch const handleAddTodo = compose(dispatch, actions.addTodo); const handleToggleTodo = compose(dispatch, actions.toggleTodo); const handleRemoveTodo = compose(dispatch, actions.removeTodo); const handleUpdateTodo = (id, text) => dispatch(actions.updateTodoText(id, text)); const handleClearCompleted = compose(dispatch, actions.clearCompleted); const handleFilterChange = compose(dispatch, actions.setFilter); return createElement('div', { className: 'todoapp' }, createElement('header', { className: 'header' }, createElement('h1', null, 'todos'), createElement(TodoForm, { onAdd: handleAddTodo }) ), todos.length > 0 && createElement('section', { className: 'main' }, createElement(TodoList, { todos, onToggle: handleToggleTodo, onRemove: handleRemoveTodo, onUpdate: handleUpdateTodo }), createElement('footer', { className: 'footer' }, createElement('span', { className: 'todo-count' }, createElement('strong', null, activeCount), ` item${activeCount !== 1 ? 's' : ''} left` ), createElement('ul', { className: 'filters' }, createElement('li', null, createElement('a', { className: currentFilter === 'all' ? 'selected' : '', onClick: () => handleFilterChange('all') }, 'All') ), createElement('li', null, createElement('a', { className: currentFilter === 'active' ? 'selected' : '', onClick: () => handleFilterChange('active') }, 'Active') ), createElement('li', null, createElement('a', { className: currentFilter === 'completed' ? 'selected' : '', onClick: () => handleFilterChange('completed') }, 'Completed') ) ), state.todos.some(t => t.completed) && createElement('button', { className: 'clear-completed', onClick: handleClearCompleted }, 'Clear completed') ) ) ); }; export default App; Putting It All Together The main entry point connects all the pieces together: // src/index.js import { createElement, render } from '../../src/core/runtime/jsx.js'; import { todoStore } from './store/todoStore.js'; import App from './components/App.js'; // Get the root element const rootElement = document.getElementById('root'); // Render function that will be called on every state change const renderApp = (state) => { render( createElement(App, { state: state, dispatch: todoStore.update }), rootElement ); }; // Subscribe to store updates todoStore.subscribe(renderApp); // Initial render todoStore.getState().map(renderApp); // For debugging window.todoStore = todoStore; HTML Structure &lt;!-- index.html --> &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> &lt;title>FlexNet Todo App&lt;/title> &lt;link rel=\"stylesheet\" href=\"styles.css\"> &lt;/head> &lt;body> &lt;div id=\"root\">&lt;/div> &lt;footer class=\"info\"> &lt;p>Double-click to edit a todo&lt;/p> &lt;p>Created with &lt;a href=\"https://github.com/flexnet/flexnet-jsx\">FlexNet JSX&lt;/a>&lt;/p> &lt;/footer> &lt;script type=\"module\" src=\"src/index.js\">&lt;/script> &lt;/body> &lt;/html> Key Concepts Demonstrated Immutable State All state updates create new state objects rather than mutating existing ones. Functional Composition Event handlers use compose() to create pipelines of functions. Pure Components Components are pure functions of their props with no internal state. Unidirectional Data Flow Data flows down through props, events flow up through callbacks. Type Safety Using Maybe for nullable values and safe state updates. Selective Rendering Conditional rendering based on state (e.g., showing clear button only when needed). Further Improvements Here are some ways to extend this example: Add local storage persistence using FlexNet's Effect system Implement drag-and-drop reordering of todos Add due dates and priority levels to todos Implement undo/redo functionality using command pattern Add categories or tags for better organization Testing the Todo App One of the benefits of functional programming is testability. Here's how you might test the actions: // Example test for addTodo action import { actions } from './store/actions.js'; import { Maybe } from '../../src/core/types/maybe.js'; // Mock state const mockState = { todos: [], filter: 'all' }; // Test addTodo action const newState = actions.addTodo('Test Todo')(mockState); // Assert: should be a Maybe.Just console.assert(newState.type === 'Just', 'Should return a Maybe.Just'); // Assert: should have one todo console.assert(newState.value.todos.length === 1, 'Should add one todo'); // Assert: new todo should have correct text console.assert(newState.value.todos[0].text === 'Test Todo', 'Todo should have correct text'); // Assert: new todo should not be completed console.assert(newState.value.todos[0].completed === false, 'Todo should not be completed'); Since actions and reducers are pure functions, they're easy to test in isolation without mocks or complex test setup. Related Resources State Management Learn more about FlexNet's immutable state system Functional Composition Explore how function composition works in FlexNet Website Example See a more complex FlexNet application Result Type Learn about error handling with the Result type"
  },
  {
    "title": "Website Example - FlexNet JSX Framework",
    "path": "examples/website.html",
    "content": "GitHub Starter Project Home / Examples / Website Website Example Building a complete website with FlexNet JSX Overview This example demonstrates how to build a complete multi-page website using FlexNet JSX, showcasing routing, data fetching, state management, and more. Key Features Functional Routing System with route parameters and guards API Integration with the Effect system Component Composition with Header, Footer, and Layout components Form Handling with validation using Maybe and Either Project Structure website-example/ ├── index.html ├── styles.css ├── src/ │ ├── index.js # Main entry point │ ├── components/ # Reusable components │ │ ├── Header.js │ │ ├── Footer.js │ │ ├── Layout.js │ │ ├── Navigation.js │ │ └── ... │ ├── pages/ # Page components │ │ ├── HomePage.js │ │ ├── AboutPage.js │ │ ├── BlogPage.js │ │ ├── ContactPage.js │ │ └── ... │ ├── features/ # Feature-specific modules │ │ ├── blog/ │ │ │ ├── BlogList.js │ │ │ ├── BlogPost.js │ │ │ └── blogStore.js │ │ ├── contact/ │ │ │ ├── ContactForm.js │ │ │ └── validators.js │ │ └── ... │ ├── router/ # Routing system │ │ ├── router.js │ │ ├── Route.js │ │ └── Link.js │ ├── api/ # API integration │ │ ├── client.js │ │ ├── blogApi.js │ │ └── contactApi.js │ └── utils/ # Utility functions │ ├── validators.js │ └── formatting.js └── README.md Key Components Router Implementation // src/router/router.js import { Maybe } from '../core/types/maybe.js'; import { createStore } from '../core/state/store.js'; export const createRouter = (routes) => { // Store current route state const routeStore = createStore({ path: window.location.pathname, params: {}, query: {} }); // Parse route parameters from path const parseParams = (routePath, currentPath) => { const routeParts = routePath.split('/').filter(Boolean); const pathParts = currentPath.split('/').filter(Boolean); if (routeParts.length !== pathParts.length) return Maybe.Nothing(); const params = {}; for (let i = 0; i { for (const route of routes) { const params = parseParams(route.path, path); if (params.isJust()) { return { component: route.component, params: params.getOrElse({}) }; } } return { component: routes.find(r => r.path === '*')?.component, params: {} }; }; // Handle navigation const navigate = (path) => { window.history.pushState(null, '', path); const { component, params } = matchRoute(path); routeStore.update(() => ({ path, params, component })); }; // Initialize router const init = () => { // Setup popstate listener window.addEventListener('popstate', () => { navigate(window.location.pathname); }); // Intercept link clicks document.addEventListener('click', (e) => { if (e.target.tagName === 'A' && e.target.getAttribute('data-internal') === 'true') { e.preventDefault(); navigate(e.target.getAttribute('href')); } }); // Initial route navigate(window.location.pathname); }; return { init, navigate, subscribe: routeStore.subscribe, getCurrentRoute: () => routeStore.getState() }; }; API Client with Effects // src/api/client.js import { createEffect } from '../core/effects/effect.js'; import { Either } from '../core/types/either.js'; export const apiClient = { // Base fetch function with Either for error handling fetch: (url, options = {}) => createEffect(({ onSuccess, onError, onLoading }) => { onLoading(true); const controller = new AbortController(); fetch(url, { ...options, signal: controller.signal, headers: { 'Content-Type': 'application/json', ...options.headers } }) .then(response => { if (!response.ok) { throw new Error(`HTTP error! status: ${response.status}`); } return response.json(); }) .then(data => { onLoading(false); onSuccess(Either.Right(data)); }) .catch(error => { if (error.name !== 'AbortError') { onLoading(false); onError(Either.Left(error.message)); } }); // Return cleanup function return () => controller.abort(); }), // GET request get: (url) => apiClient.fetch(url), // POST request post: (url, data) => apiClient.fetch(url, { method: 'POST', body: JSON.stringify(data) }), // PUT request put: (url, data) => apiClient.fetch(url, { method: 'PUT', body: JSON.stringify(data) }), // DELETE request delete: (url) => apiClient.fetch(url, { method: 'DELETE' }) }; Form Handling with Validation // src/features/contact/ContactForm.js import { createElement } from '../../core/jsx.js'; import { createStore } from '../../core/state/store.js'; import { Either } from '../../core/types/either.js'; import { apiClient } from '../../api/contactApi.js'; import { runEffect } from '../../core/effects/effect.js'; import { validateEmail, validateRequired } from './validators.js'; export const ContactForm = () => { // Form state const formStore = createStore({ name: '', email: '', message: '', errors: {}, submitting: false, submitted: false }); // Update field value const updateField = (field, value) => { formStore.update(state => ({ ...state, [field]: value, errors: { ...state.errors, [field]: null // Clear error when field is updated } })); }; // Validate form const validateForm = () => { const { name, email, message } = formStore.getState(); const errors = {}; // Validate name validateRequired(name, 'Name is required') .fold( error => { errors.name = error; }, () => {} ); // Validate email validateEmail(email) .fold( error => { errors.email = error; }, () => {} ); // Validate message validateRequired(message, 'Message is required') .fold( error => { errors.message = error; }, () => {} ); // Update errors in state formStore.update(state => ({ ...state, errors })); // Return whether form is valid return Object.keys(errors).length === 0; }; // Handle form submission const handleSubmit = (e) => { e.preventDefault(); if (!validateForm()) return; const { name, email, message } = formStore.getState(); // Set submitting state formStore.update(state => ({ ...state, submitting: true })); // Submit form data runEffect(apiClient.post('/api/contact', { name, email, message }), { onSuccess: (result) => { result.fold( error => { formStore.update(state => ({ ...state, submitting: false, errors: { form: error } })); }, () => { formStore.update(state => ({ ...state, submitting: false, submitted: true, name: '', email: '', message: '' })); } ); }, onError: (error) => { formStore.update(state => ({ ...state, submitting: false, errors: { form: error.getOrElse('An error occurred') } })); } }); }; // Render form return () => { const { name, email, message, errors, submitting, submitted } = formStore.getState(); if (submitted) { return createElement('div', { className: 'success-message' }, createElement('h3', null, 'Thank you for your message!'), createElement('p', null, 'We will get back to you soon.'), createElement('button', { className: 'btn btn-primary mt-4', onClick: () => formStore.update(state => ({ ...state, submitted: false })) }, 'Send another message') ); } return createElement('form', { onSubmit: handleSubmit, className: 'contact-form' }, createElement('div', { className: 'form-group' }, createElement('label', { htmlFor: 'name' }, 'Name'), createElement('input', { type: 'text', id: 'name', value: name, onChange: (e) => updateField('name', e.target.value), className: errors.name ? 'input-error' : '' }), errors.name && createElement('div', { className: 'error' }, errors.name) ), createElement('div', { className: 'form-group' }, createElement('label', { htmlFor: 'email' }, 'Email'), createElement('input', { type: 'email', id: 'email', value: email, onChange: (e) => updateField('email', e.target.value), className: errors.email ? 'input-error' : '' }), errors.email && createElement('div', { className: 'error' }, errors.email) ), createElement('div', { className: 'form-group' }, createElement('label', { htmlFor: 'message' }, 'Message'), createElement('textarea', { id: 'message', value: message, onChange: (e) => updateField('message', e.target.value), rows: 5, className: errors.message ? 'input-error' : '' }), errors.message && createElement('div', { className: 'error' }, errors.message) ), errors.form && createElement('div', { className: 'form-error' }, errors.form), createElement('button', { type: 'submit', className: 'btn btn-primary', disabled: submitting }, submitting ? 'Sending...' : 'Send Message') ); }; }; Main Application // src/index.js import { createElement, render } from './core/jsx.js'; import { createRouter } from './router/router.js'; import { Layout } from './components/Layout.js'; import { HomePage } from './pages/HomePage.js'; import { AboutPage } from './pages/AboutPage.js'; import { BlogPage } from './pages/BlogPage.js'; import { BlogPostPage } from './pages/BlogPostPage.js'; import { ContactPage } from './pages/ContactPage.js'; import { NotFoundPage } from './pages/NotFoundPage.js'; // Define routes const routes = [ { path: '/', component: HomePage }, { path: '/about', component: AboutPage }, { path: '/blog', component: BlogPage }, { path: '/blog/:id', component: BlogPostPage }, { path: '/contact', component: ContactPage }, { path: '*', component: NotFoundPage } ]; // Create router const router = createRouter(routes); // App component const App = () => { // Subscribe to route changes router.subscribe(({ component, params }) => { // Render the current route component within the layout render( createElement(Layout, null, createElement(component, { params }) ), document.getElementById('root') ); }); // Initialize router router.init(); }; // Start the application document.addEventListener('DOMContentLoaded', App); Running the Example To run this example: # Clone the starter project cd starter-project-website python -m http.server 3000 # Open http://localhost:3000 Note This example uses a mock API for demo purposes. In a real application, you would connect to your backend services. Key Takeaways Functional Architecture The website example demonstrates a complete functional architecture with pure components and immutable state. Component Composition Components are composed together to create complex UIs while maintaining separation of concerns. Type-Safe Error Handling Either and Maybe types provide robust error handling throughout the application. Side Effect Management Effects are cleanly isolated and managed, making the code easier to test and maintain. Next Steps JSX Runtime Learn more about the JSX runtime that powers this example. Effect System Explore how the effect system works for API calls and side effects. Either Type Learn more about the Either type used for error handling. Maybe Type Understand how the Maybe type handles optional values. Looking for more examples? Check out our Todo App Example for a simpler application that focuses on state management."
  },
  {
    "title": "Either - FlexNet JSX Framework",
    "path": "api/either.html",
    "content": "GitHub Starter Project Home / API / Either Either The Either type represents values with two possibilities: a value of type Left or a value of type Right. Overview The Either type is a functional programming construct that represents a value which is either a \"Left\" or a \"Right\". Typically, the Left side represents an error or failure case, while the Right side represents a success or valid value. This approach provides several advantages over traditional error handling: No exceptions or runtime errors Type-safe error handling Composition of operations that might fail Clear, explicit error paths Basic Usage Here's a simple example of how to use the Either type: import { Either } from './src/core/types/either.js'; // Create Either values const right = Either.Right(42); const left = Either.Left('Error message'); // Check which variant we have console.log(right.isRight()); // true console.log(right.isLeft()); // false console.log(left.isRight()); // false console.log(left.isLeft()); // true // Safely extract values console.log(right.getOrElse(0)); // 42 console.log(left.getOrElse(0)); // 0 Common Use Cases The Either type is commonly used for: Error Handling Represent operations that might fail with detailed error information. Branching Logic Represent two distinct paths in your code. Validation Return valid values or validation errors. Parsing Return parsed data or parsing errors. Error Handling Example // Division function that can't divide by zero const safeDivide = (a, b) => b === 0 ? Either.Left('Division by zero') : Either.Right(a / b); // Usage const result = safeDivide(10, 2) .map(n => n * 2) // Only runs if Right .mapLeft(e => `Error: ${e}`); // Only runs if Left console.log(result.getOrElse('Calculation failed')); // 10 Validation Example // Validate a username const validateUsername = (username) => { if (!username) { return Either.Left('Username is required'); } if (username.length console.error(error), // Left case username => console.log(`Valid username: ${username}`) // Right case ); API Reference Static Methods Method Description Either.Left(value) Creates a new Left instance containing the given value. Either.Right(value) Creates a new Right instance containing the given value. Either.fromNullable(value, error) Returns a Right with the value if it's not null or undefined, otherwise a Left with the given error. Either.try(fn) Executes the function and returns a Right with the result if it succeeds, or a Left with the error if it throws. Instance Methods Method Description isLeft() Returns true if this is a Left, false otherwise. isRight() Returns true if this is a Right, false otherwise. map(fn) If this is a Right, applies the function to the value and returns a new Right. If this is a Left, returns this Left unchanged. mapLeft(fn) If this is a Left, applies the function to the value and returns a new Left. If this is a Right, returns this Right unchanged. chain(fn) If this is a Right, applies the function to the value and returns the result. If this is a Left, returns this Left unchanged. getOrElse(defaultValue) If this is a Right, returns the value. If this is a Left, returns the defaultValue. fold(leftFn, rightFn) Applies leftFn if this is a Left, or rightFn if this is a Right, and returns the result. swap() Converts a Left to a Right and a Right to a Left. Advanced Usage Chaining Operations Either shines when you need to chain multiple operations that might fail: // Validation functions const validateEmail = email => /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(email) ? Either.Right(email) : Either.Left('Invalid email format'); const validatePassword = password => password.length >= 8 ? Either.Right(password) : Either.Left('Password must be at least 8 characters'); const validateUser = user => user && user.name ? Either.Right(user) : Either.Left('User must have a name'); // Chain validations const validateUserData = (userData) => { return validateUser(userData) .chain(user => validateEmail(user.email) .map(email => ({ ...user, email })) ) .chain(user => validatePassword(user.password) .map(password => ({ ...user, password })) ); }; // Usage const userData = { name: 'John Doe', email: 'john@example.com', password: 'secretpass' }; const result = validateUserData(userData); result.fold( error => console.error(`Validation failed: ${error}`), user => console.log('User is valid:', user) ); Converting from Try/Catch Convert traditional try/catch blocks to Either for more functional error handling: // Parse JSON with Either const parseJSON = str => Either.try(() => JSON.parse(str)); // Usage const jsonStr = '{\"name\": \"John\", \"age\": 30}'; const invalidJson = '{name: John}'; const result1 = parseJSON(jsonStr); // Right({name: \"John\", age: 30}) const result2 = parseJSON(invalidJson); // Left(SyntaxError) // Handle both cases with fold result1.fold( error => console.error('Parsing failed:', error.message), data => console.log('Name:', data.name, 'Age:', data.age) ); Combining with Maybe Either and Maybe work well together for handling both nullability and errors: import { Maybe } from './src/core/types/maybe.js'; import { Either } from './src/core/types/either.js'; // Get user from storage, which might be null const getUserFromStorage = (id) => { const user = localStorage.getItem(`user_${id}`); return Maybe.fromNullable(user); }; // Parse the user JSON, which might fail const parseUser = (userJson) => Either.try(() => JSON.parse(userJson)); // Combined operation const getUser = (id) => { return getUserFromStorage(id) .toEither('User not found') // Convert Maybe to Either .chain(parseUser); // Chain with another Either operation }; // Usage const user = getUser(123); user.fold( error => console.error('Error:', error), userData => console.log('User:', userData) ); Integration with Other FlexNet Features Using Either with Effects Either works well with the effect system for handling asynchronous operations: import { createEffect, runEffect } from './src/systems/effects/effect.js'; import { Either } from './src/core/types/either.js'; // Fetch data effect that returns Either const fetchDataEffect = (url) => createEffect(({ onComplete }) => { fetch(url) .then(response => { if (!response.ok) { return Either.Left(`HTTP error: ${response.status}`); } return response.json() .then(data => Either.Right(data)) .catch(err => Either.Left(`JSON parse error: ${err.message}`)); }) .then(either => onComplete(either)) .catch(err => onComplete(Either.Left(`Network error: ${err.message}`))); return () => {}; // Cleanup function }); // Usage runEffect(fetchDataEffect('/api/users'), { onComplete: result => { result.fold( error => console.error('Failed to fetch users:', error), users => console.log('Users:', users) ); } }); Using Either with State Management Either can be used in state management to handle loading states and errors: import { createStore } from './src/systems/state/store.js'; import { Either } from './src/core/types/either.js'; // Initial state: not loaded const initialState = { data: Either.Left('Data not loaded'), loading: false }; // Create store const store = createStore(initialState); // Action creators const setLoading = loading => state => ({ ...state, loading }); const setData = data => state => ({ ...state, data: Either.Right(data), loading: false }); const setError = error => state => ({ ...state, data: Either.Left(error), loading: false }); // Async action to load data const loadData = () => { store.update(setLoading(true)); fetch('/api/data') .then(response => { if (!response.ok) throw new Error(`HTTP error: ${response.status}`); return response.json(); }) .then(data => store.update(setData(data))) .catch(error => store.update(setError(error.message))); }; // Component rendering based on state const renderComponent = () => { const { data, loading } = store.getState(); if (loading) { return ' Loading... '; } return data.fold( error => ` Error: ${error} `, data => ` ${JSON.stringify(data)} ` ); }; Browser Support The Either implementation in FlexNet JSX works in all modern browsers: Browser Support Chrome Latest Firefox Latest Safari Latest Edge Latest Next Steps Maybe Type Learn about the Maybe type for handling optional values. Result Type Explore the Result type for operation outcomes. Error Handling Learn more about error handling in FlexNet JSX. Todo App Example See Either in action in a complete application. Looking for more examples? Check out our Type System documentation for more advanced usage patterns with Either and other functional types."
  },
  {
    "title": "JSX API - FlexNet JSX Framework",
    "path": "api/jsx.html",
    "content": "GitHub Starter Project Home / API / JSX JSX API The core API for creating and rendering JSX elements in FlexNet JSX. Core Functions The JSX API provides the following core functions for working with JSX elements: createElement Creates a virtual DOM element that can be rendered to the DOM. Signature function createElement( type: string | Function, props: object | null, ...children: any[] ): VNode; Parameters Name Type Description type string | Function The type of element to create. A string for HTML elements (e.g., 'div', 'span') or a function for components. props object | null The properties (attributes and event handlers) to apply to the element. Can be null if no props are needed. children any[] The child elements or content. Can be other VNode elements, strings, numbers, or arrays of these. Example import { createElement } from './src/core/runtime/jsx.js'; // Creating a simple element const button = createElement('button', { onClick: () => console.log('Clicked!'), className: 'btn' }, 'Click Me' ); // Creating a nested element structure const card = createElement('div', { className: 'card' }, createElement('h2', null, 'Card Title'), createElement('p', null, 'Card content goes here'), button ); render Renders a virtual DOM element into a DOM container. Signature function render( element: VNode, container: HTMLElement, callback?: () => void ): void; Parameters Name Type Description element VNode The virtual DOM element to render. container HTMLElement The DOM container to render into. callback () => void Optional callback to execute after rendering is complete. Example import { createElement, render } from './src/core/runtime/jsx.js'; // Create an element const app = createElement('div', { className: 'app' }, createElement('h1', null, 'Hello, World!'), createElement('p', null, 'Welcome to FlexNet JSX') ); // Render it to the DOM render(app, document.getElementById('root'), () => { console.log('Rendering complete!'); }); createFragment Creates a fragment that can contain multiple elements without adding an extra DOM node. Signature function createFragment( children: any[] ): VNode; Parameters Name Type Description children any[] The child elements or content to include in the fragment. Example import { createElement, createFragment } from './src/core/runtime/jsx.js'; // A component that returns multiple elements without a wrapper const UserInfo = ({ user }) => createFragment([ createElement('h2', null, user.name), createElement('p', null, `Email: ${user.email}`), createElement('p', null, `Role: ${user.role}`) ]); Virtual DOM Types VNode The core structure representing a virtual DOM node in FlexNet JSX. Structure interface VNode { type: string | Function | Symbol; // Element type or component props: { children: any[]; // Child elements [key: string]: any; // Other properties }; key?: string | number; // Optional key for efficient updates } Using JSX Syntax FlexNet JSX supports the JSX syntax when used with a JSX compiler or transpiler. The JSX syntax is transformed into createElement calls at build time. JSX Transformation JSX Syntax const element = ( Hello, World! Welcome to FlexNet JSX ); Transformed Output const element = createElement( 'div', { className: 'container' }, createElement('h1', null, 'Hello, World!'), createElement('p', null, 'Welcome to FlexNet JSX') ); JSX Configuration To use JSX with FlexNet, you need to configure your transpiler to use the FlexNet JSX runtime: Babel Configuration { \"presets\": [ \"@babel/preset-env\" ], \"plugins\": [ [\"@babel/plugin-transform-react-jsx\", { \"pragma\": \"createElement\", \"pragmaFrag\": \"createFragment\", \"importSource\": \"./src/core/runtime\" }] ] } TypeScript Configuration { \"compilerOptions\": { \"jsx\": \"react\", \"jsxFactory\": \"createElement\", \"jsxFragmentFactory\": \"createFragment\" // other options... } } Special Props FlexNet JSX supports several special props that have specific behavior: Special Properties Prop Description key A special string attribute for uniquely identifying elements in lists. Not actually set as a property on the DOM element. ref A callback that receives the corresponding DOM element or component instance. dangerouslySetInnerHTML An object with a __html property containing HTML to inject directly into the element. Use with caution due to XSS risks. className Maps to the DOM's class attribute for CSS classes. htmlFor Maps to the DOM's for attribute for label elements. Example Usage import { createElement } from './src/core/runtime/jsx.js'; // Using the key prop for list items const list = createElement('ul', null, items.map(item => createElement('li', { key: item.id }, item.text) ) ); // Using ref to get DOM element reference let inputRef; const form = createElement('form', null, createElement('input', { type: 'text', ref: el => { inputRef = el; } }), createElement('button', { onClick: () => { console.log('Input value:', inputRef.value); } }, 'Submit') ); // Using dangerouslySetInnerHTML (with caution) const content = createElement('div', { dangerouslySetInnerHTML: { __html: sanitizedHtml // Make sure this is properly sanitized! } }); Best Practices Always provide a unique key prop when rendering lists to optimize updates Avoid using dangerouslySetInnerHTML unless absolutely necessary When using dangerouslySetInnerHTML , always sanitize the HTML content first Prefer functional components over class components for better composition Keep components small and focused on a single responsibility Related Documentation JSX Runtime Learn about the runtime implementation details of the JSX engine. Render System Understand how the render system works with JSX elements."
  },
  {
    "title": "Maybe API - FlexNet JSX Framework",
    "path": "api/maybe.html",
    "content": "GitHub Starter Project Home / API / Maybe Maybe API The Maybe type is a functional programming construct to handle the possibility of missing values in a composable, safe way. Key Concepts Using Maybe instead of null/undefined checks helps eliminate null reference errors and makes your code more robust and predictable. Basic Concept The Maybe type represents a value that may or may not exist. It has two variants: Just(value) : Contains a value Nothing : Represents the absence of a value This approach replaces the need for null checks throughout your code and provides a consistent way to handle potentially missing values. Creating Maybe Values Constructors import { Maybe } from './src/core/types/maybe.js'; // Creates a Maybe containing a value Maybe.Just(42) // Creates an empty Maybe Maybe.Nothing() // Creates Just if value is not null/undefined, otherwise Nothing Maybe.fromNullable(user.address) // Alias for Just, creates a Maybe containing value Maybe.of('hello') Creating Maybe Values Example import { Maybe } from './src/core/types/maybe.js'; // Creating Maybe values const justValue = Maybe.Just(42); const nothingValue = Maybe.Nothing(); // Converting from nullable values const username = Maybe.fromNullable(user.username); const settings = Maybe.fromNullable(localStorage.getItem('settings')); Working with Maybe Values Methods // Transforms the value inside a Just, does nothing for Nothing maybe.map(x => x * 2) // Maps and flattens the result (function must return a Maybe) maybe.flatMap(x => Maybe.Just(x + 1)) // Returns the value or a default if Nothing maybe.getOrElse('default') // Converts Just to Nothing if predicate fails maybe.filter(x => x > 0) // Applies functions based on whether value is Just or Nothing maybe.fold(() => 0, x => x * 2) // Returns true if value is Just maybe.isJust() // Returns true if value is Nothing maybe.isNothing() Transformation Methods Example import { Maybe } from './src/core/types/maybe.js'; // User might be null/undefined const user = getUser(userId); // Using Maybe to safely handle user data const greeting = Maybe.fromNullable(user) .map(u => u.name) // Will only run if user exists .map(name => `Hello, ${name}!`) .getOrElse('Hello, Guest!'); // Default value if user or name is missing // Complex transformations with filtering const discountCode = Maybe.fromNullable(user) .filter(u => u.isPremium) // Continue only if user is premium .flatMap(u => Maybe.fromNullable(u.discountCodes[0])) // Safely access first discount code .map(code => code.toUpperCase()) .getOrElse('NO_DISCOUNT'); Common Use Cases 1. Safe Property Access // Without Maybe const streetName = user && user.address && user.address.street ? user.address.street : 'Unknown'; // With Maybe const streetName = Maybe.fromNullable(user) .flatMap(u => Maybe.fromNullable(u.address)) .flatMap(a => Maybe.fromNullable(a.street)) .getOrElse('Unknown'); 2. Form Validation const validateEmail = email => { const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/; return emailRegex.test(email) ? Maybe.Just(email) : Maybe.Nothing(); }; const userEmail = validateEmail(formData.email) .getOrElse('Invalid email'); 3. API Response Handling const fetchUserData = async (userId) => { try { const response = await fetch(`/api/users/${userId}`); if (!response.ok) return Maybe.Nothing(); const data = await response.json(); return Maybe.fromNullable(data); } catch (error) { return Maybe.Nothing(); } }; // Usage fetchUserData(123) .map(renderUserProfile) // Only runs if user data exists .getOrElse(renderNotFound()); Integration with JSX Maybe works seamlessly with FlexNet's JSX implementation for conditional rendering: import { createElement } from './src/core/runtime/jsx.js'; import { Maybe } from './src/core/types/maybe.js'; const UserProfile = ({ userData }) => { // Safely extract user info with Maybe const userMaybe = Maybe.fromNullable(userData); // Conditional rendering based on presence of user data return userMaybe .map(user => createElement('div', { className: 'user-profile' }, createElement('h2', null, user.name), createElement('p', null, user.email), createElement('p', null, user.bio || 'No bio provided') ) ) .getOrElse( createElement('div', { className: 'user-profile-empty' }, createElement('p', null, 'User not found') ) ); }; Composing Multiple Maybe Values When you need to combine multiple Maybe values, you can use the lift operation: import { Maybe } from './src/core/types/maybe.js'; // Helper to lift a function to work with Maybe values const lift = (fn) => (...maybes) => { // Check if any value is Nothing const hasNothing = maybes.some(m => m.isNothing()); if (hasNothing) return Maybe.Nothing(); // Extract all values and apply function const values = maybes.map(m => m.getOrElse(null)); return Maybe.Just(fn(...values)); }; // Example: Safe addition of potentially missing values const add = (a, b) => a + b; const liftedAdd = lift(add); const maybeA = Maybe.Just(5); const maybeB = Maybe.Just(10); const maybeC = Maybe.Nothing(); liftedAdd(maybeA, maybeB); // Just(15) liftedAdd(maybeA, maybeC); // Nothing() Performance Considerations While Maybe adds safety, it's important to consider performance implications: Maybe operations create new instances, so excessive chaining in tight loops may impact performance For hot paths, consider using inline null checks if performance is critical The mental model and safety benefits usually outweigh the minor performance costs Related Types Either Type For values that can be one of two types (Left or Right) Result Type For operations that can succeed (Ok) or fail (Error)"
  },
  {
    "title": "Result API - FlexNet JSX Framework",
    "path": "api/result.html",
    "content": "GitHub Starter Project Home / API / Result Result API The Result type represents the result of an asynchronous operation that can succeed with a value or fail with an error. Overview The Result type is a Promise-compatible type for handling asynchronous operations in a functional way. It has two variants: Ok(value) : Represents a successful operation with a value Error(error) : Represents a failed operation with an error Unlike native Promises that mix success and failure in callbacks, Result uses explicit types to handle both cases, making error handling more predictable and comprehensive. Key Features Promise-compatible: works with async/await and .then() Pattern matching with match() for handling both success and error cases Chainable transformations with map() and mapError() Error recovery with recover() and orElse() Exception handling with try() Creating Results There are several ways to create Result instances: Basic Constructors import { Result } from './src/core/types/result.js'; // Create a successful Result const success = Result.Ok(42); // Create a failed Result const failure = Result.Error('Something went wrong'); From Promises // Convert a Promise to a Result const fetchUser = async (userId) => { try { const response = await fetch(`/api/users/${userId}`); if (!response.ok) { return Result.Error(`Failed with status: ${response.status}`); } const data = await response.json(); return Result.Ok(data); } catch (error) { return Result.Error(`Network error: ${error.message}`); } }; From Functions (try/catch) // Safely execute a function that might throw const parseJSON = (json) => { return Result.try(() => JSON.parse(json)); }; // Usage const result = parseJSON('{\"name\": \"John\"}'); // Result.Ok({name: \"John\"}) const invalid = parseJSON('invalid json'); // Result.Error(SyntaxError: Unexpected token i in JSON at position 0) Working with Results Pattern Matching Use match() to handle both success and error cases: // Fetch user data fetchUser(123) .then(result => result.match({ Ok: user => { // Handle successful case displayUserProfile(user); }, Error: error => { // Handle error case showErrorMessage(error); } })); Transforming Results Transform the value inside a Result using map() and mapError() : // Transform the success value const nameResult = fetchUser(123) .then(result => result.map(user => user.name)); // Transform the error const friendlyErrorResult = fetchUser(123) .then(result => result.mapError(error => { if (error.includes('404')) { return 'User not found'; } return 'An error occurred. Please try again.'; })); Chaining Results Chain multiple async operations with chain() : // Chain multiple operations const getUserWithPosts = (userId) => { return fetchUser(userId) .then(userResult => userResult.chain(user => fetchPosts(user.id) .then(postsResult => postsResult.map(posts => ({ ...user, posts })) ) ) ); }; Error Recovery Recover from errors with recover() or orElse() : // Recover with a default value const userOrDefault = fetchUser(123) .then(result => result.recover(error => ({ name: 'Guest', id: 0 }))); // Recover with another Result (fallback) const userOrFallback = fetchUser(123) .then(result => result.orElse(error => { if (error.includes('404')) { return fetchDefaultUser(); } return Result.Error(error); })); Using with async/await Result works seamlessly with async/await, but requires pattern matching to handle the Result type: // Using Result with async/await async function loadUserProfile(userId) { const result = await fetchUser(userId); return result.match({ Ok: user => { return renderProfile(user); }, Error: error => { return renderError(error); } }); } Result API Reference Static Methods Result.Ok(value) Creates a successful Result with the given value. const okResult = Result.Ok(42); Result.Error(error) Creates a failed Result with the given error. const errorResult = Result.Error('Something went wrong'); Result.try(fn) Executes a function and wraps the result in a Result, catching any thrown exceptions. const result = Result.try(() => JSON.parse('{\"name\": \"John\"}')); Result.all(results) Combines an array of Results into a single Result containing an array of values. If any Result is an Error, the combined Result will be the first encountered Error. const results = [ Result.Ok(1), Result.Ok(2), Result.Ok(3) ]; const combined = await Result.all(results); // Result.Ok([1, 2, 3]) Instance Methods match({ Ok, Error }) Pattern matches on the Result, executing the appropriate handler based on whether it's Ok or Error. result.match({ Ok: value => console.log('Success:', value), Error: error => console.error('Error:', error) }); map(fn) Transforms the value inside an Ok result using the provided function. If the Result is an Error, it's returned unchanged. const doubled = Result.Ok(21).map(x => x * 2); // Result.Ok(42) mapError(fn) Transforms the error inside an Error result using the provided function. If the Result is Ok, it's returned unchanged. const friendlyError = Result.Error('NOT_FOUND') .mapError(err => `Resource not found: ${err}`); // Result.Error('Resource not found: NOT_FOUND') chain(fn) Transforms an Ok result using a function that returns another Result. If the original Result is an Error, it's returned unchanged. const validatedResult = Result.Ok('john@example.com') .chain(email => { if (isValidEmail(email)) { return Result.Ok(email); } return Result.Error('Invalid email'); }); recover(fn) Transforms an Error result into an Ok result using the provided recovery function. If the Result is already Ok, it's returned unchanged. const recovered = Result.Error('Not found') .recover(error => 'Default value'); // Result.Ok('Default value') orElse(fn) Transforms an Error result into another Result using the provided function. If the original Result is Ok, it's returned unchanged. const fallback = Result.Error('Primary source failed') .orElse(error => fetchFromBackupSource()); // A new Result from the backup source Best Practices Always handle both Ok and Error cases when working with Results Use Result.try() to safely execute functions that might throw exceptions Prefer using match() for explicit handling of both success and error cases Use chain() for composing multiple operations that return Results Convert Promises to Results for more explicit error handling Related Documentation Maybe Learn about the Maybe type for handling optional values. Either Explore the Either type for handling synchronous operations that can fail. Error Handling Learn about FlexNet's comprehensive error handling system. Effects System Understand how to handle side effects in a functional way."
  },
  {
    "title": "Store API - FlexNet JSX Framework",
    "path": "api/store.html",
    "content": "GitHub Starter Project Home / API / Store Store API The Store API provides a functional, immutable state management solution for FlexNet JSX applications. Overview The Store is a container for application state that follows functional programming principles. It provides a way to manage state with the following features: Immutable state updates Pure functional updates Observable state changes Time-travel debugging capabilities Integration with FlexNet's type system Key Concepts State : The current data stored in the Store Update : A pure function that transforms the current state to a new state Subscribers : Functions that are called whenever the state changes History : A record of previous states for debugging and time-travel Creating a Store You can create a Store using the createStore function: import { createStore } from './src/systems/state/store.js'; // Create a store with initial state const counterStore = createStore(0); // Create a store with an object as initial state const userStore = createStore({ name: 'John', age: 30, isLoggedIn: true }); // Create a store with a Maybe value import { Maybe } from './src/core/types/maybe.js'; const optionalUserStore = createStore(Maybe.Just({ name: 'John', age: 30 })); Reading State You can access the current state of a Store using getState() : // Get the current state const count = counterStore.getState(); console.log(count); // 0 // Get the current state from an object store const user = userStore.getState(); console.log(user.name); // 'John' // Get state from a Maybe store optionalUserStore.getState().match({ Just: user => console.log(user.name), // 'John' Nothing: () => console.log('No user available') }); Updating State You can update the state of a Store using update() , which takes a pure function that transforms the current state to a new state: // Update with a function that takes the current state counterStore.update(count => count + 1); // Update an object store userStore.update(user => ({ ...user, age: user.age + 1 })); // Update a Maybe store optionalUserStore.update(maybeUser => maybeUser.map(user => ({ ...user, age: user.age + 1 })) ); Update with Direct Value You can also update a Store with a direct value: // Set a new value directly counterStore.update(42); // Set a new object directly userStore.update({ name: 'Jane', age: 28, isLoggedIn: true }); // Set a new Maybe value optionalUserStore.update(Maybe.Nothing()); Subscribing to Changes You can subscribe to state changes using subscribe() , which takes a callback function that will be called whenever the state changes: // Subscribe to state changes const unsubscribe = counterStore.subscribe(newCount => { console.log('Count changed:', newCount); // Update UI or perform other actions }); // Later, when you no longer need the subscription unsubscribe(); // Multiple subscribers userStore.subscribe(user => { console.log('User changed:', user); }); userStore.subscribe(user => { renderUserProfile(user); }); Using with Components A common pattern is to subscribe to store changes and re-render components: import { createElement, render } from './src/core/runtime/jsx.js'; import { createStore } from './src/systems/state/store.js'; // Create a store const counterStore = createStore(0); // Counter component const Counter = ({ count, onIncrement, onDecrement }) => createElement('div', null, createElement('h2', null, `Count: ${count}`), createElement('button', { onClick: onIncrement }, '+'), createElement('button', { onClick: onDecrement }, '-') ); // Subscribe to state changes and re-render counterStore.subscribe(count => { render( createElement(Counter, { count, onIncrement: () => counterStore.update(c => c + 1), onDecrement: () => counterStore.update(c => c - 1) }), document.getElementById('root') ); }); Combining Multiple Stores You can create derived stores or combine multiple stores for more complex state management: import { createStore } from './src/systems/state/store.js'; // Create individual stores const usersStore = createStore([]); const filterStore = createStore(''); // Create a derived store const filteredUsersStore = createDerivedStore( [usersStore, filterStore], ([users, filter]) => { if (!filter) return users; return users.filter(user => user.name.toLowerCase().includes(filter.toLowerCase()) ); } ); // Usage filteredUsersStore.subscribe(filteredUsers => { renderUserList(filteredUsers); }); // Update source stores usersStore.update(users => [...users, { id: 1, name: 'John' }]); filterStore.update('jo'); // Will cause filteredUsersStore to update Time Travel Debugging The Store includes built-in support for time-travel debugging: // Enable history tracking (in development mode) counterStore.enableHistory(); // Make some updates counterStore.update(count => count + 1); counterStore.update(count => count + 1); counterStore.update(count => count + 1); // Get the history const history = counterStore.getHistory(); console.log(history); // [0, 1, 2, 3] // Time travel to a previous state counterStore.timeTravel(1); // Go back to state at index 1 Store API Reference createStore Signature function createStore (initialState: T): Store ; Parameters Name Type Description initialState T The initial state of the store. Returns A new Store instance with the specified initial state. Store Methods getState() Returns the current state of the store. function getState(): T; update(updaterOrValue) Updates the state of the store using an updater function or a direct value. function update(updaterOrValue: ((state: T) => T) | T): void; subscribe(subscriber) Subscribes to state changes, calling the subscriber function whenever the state changes. function subscribe(subscriber: (state: T) => void): () => void; Returns an unsubscribe function that can be called to remove the subscription. enableHistory() Enables history tracking for time-travel debugging. function enableHistory(): void; disableHistory() Disables history tracking. function disableHistory(): void; getHistory() Returns the history of states if history tracking is enabled. function getHistory(): T[]; timeTravel(index) Restores the state to a previous point in history. function timeTravel(index: number): void; Advanced Usage Using Selectors Selectors help extract specific parts of the state: import { createStore, createSelector } from './src/systems/state/store.js'; // Create a store with complex state const appStore = createStore({ users: [ { id: 1, name: 'John', role: 'admin' }, { id: 2, name: 'Jane', role: 'user' } ], settings: { theme: 'light', notifications: true }, ui: { sidebar: 'open', activeTab: 'dashboard' } }); // Create selectors const selectUsers = state => state.users; const selectAdmins = createSelector( selectUsers, users => users.filter(user => user.role === 'admin') ); const selectTheme = state => state.settings.theme; // Use selectors appStore.subscribe(state => { const admins = selectAdmins(state); console.log('Admins:', admins); const theme = selectTheme(state); document.body.className = theme; }); Middleware You can enhance stores with middleware for cross-cutting concerns: import { createStore, applyMiddleware } from './src/systems/state/store.js'; // Logger middleware const logger = store => next => action => { console.log('State before:', store.getState()); const result = next(action); console.log('State after:', store.getState()); return result; }; // Validation middleware const validator = schema => store => next => action => { const newState = typeof action === 'function' ? action(store.getState()) : action; const validationResult = validateState(newState, schema); if (validationResult.isValid) { return next(action); } else { console.error('Invalid state:', validationResult.errors); return store.getState(); // Don't update if invalid } }; // Create store with middleware const userSchema = { name: { type: 'string', required: true }, age: { type: 'number', min: 0, max: 120 } }; const userStore = createStore( { name: 'John', age: 30 }, applyMiddleware( logger, validator(userSchema) ) ); Best Practices Keep store state as simple and flat as possible Use multiple small stores instead of one large store Use pure functions for state updates Prefer composition of stores over complex nested state Use selectors to derive computed state Only enable history tracking in development mode Related Documentation State Management Learn about FlexNet's overall state management philosophy. Type System Understand how the type system integrates with state management. Todo App Example See a complete example of using the Store API in a real application. Effects System Learn how to handle side effects in relation to state changes."
  }
]