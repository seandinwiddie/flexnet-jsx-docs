<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Render System - FlexNet JSX Framework</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#3b82f6',
                        secondary: '#6366f1',
                        dark: '#1e293b',
                        light: '#f8fafc'
                    }
                }
            }
        }
        hljs.highlightAll();
    </script>
</head>
<body class="bg-gray-50 text-gray-900 min-h-screen">
    <div class="flex">
        <!-- Sidebar -->
        <aside id="sidebar-placeholder" class="w-64 bg-white border-r border-gray-200 h-screen sticky top-0 overflow-y-auto flex-shrink-0">
        </aside>

        <!-- Main content -->
        <main class="flex-1 overflow-y-auto">
            <header id="header-placeholder" class="border-b border-gray-200 bg-white sticky top-0 z-10">
            </header>

            <div class="p-8 max-w-5xl mx-auto">
                <div class="flex items-center space-x-2 text-sm text-gray-500 mb-8">
                    <a href="../index.html" class="hover:text-primary">Home</a>
                    <span>/</span>
                    <a href="state.html" class="hover:text-primary">Systems</a>
                    <span>/</span>
                    <span class="text-gray-700">Render</span>
                </div>

                <h1 class="text-4xl font-bold mb-6">Render System</h1>
                <p class="text-lg text-gray-600 mb-8">The FlexNet JSX render system efficiently translates virtual DOM elements into real DOM nodes while maintaining purity and immutability.</p>

                <div class="prose prose-blue max-w-none">
                    <h2 class="text-2xl font-semibold mb-4 mt-8 border-b pb-2">Overview</h2>
                    <p class="mb-4">The render system in FlexNet JSX is responsible for converting the virtual DOM elements created by the JSX runtime into actual DOM elements that can be displayed in the browser. The system is designed with functional programming principles in mind, ensuring that rendering operations are pure, predictable, and efficient.</p>

                    <div class="bg-blue-50 border-l-4 border-primary p-4 rounded-md mb-6">
                        <h4 class="font-semibold">Key Features</h4>
                        <ul class="list-disc pl-6 mt-2">
                            <li>Pure functional rendering with no side effects</li>
                            <li>Efficient diffing algorithm for minimal DOM updates</li>
                            <li>Immutable virtual DOM representation</li>
                            <li>Component-based architecture</li>
                            <li>Support for functional components</li>
                        </ul>
                    </div>

                    <h2 class="text-2xl font-semibold mb-4 mt-8 border-b pb-2">Basic Rendering</h2>
                    <p class="mb-4">The core of the render system is the <code>render</code> function, which takes a virtual DOM element and a DOM container, and mounts the element into the container.</p>

                    <pre class="bg-gray-800 text-white p-4 rounded-lg mb-6"><code class="language-javascript">import { createElement, render } from './src/systems/render/functions.js';

// Create a virtual DOM element
const element = createElement('div', { className: 'greeting' }, 'Hello, World!');

// Render it to the DOM
render(element, document.getElementById('root'));</code></pre>

                    <h3 class="text-xl font-medium mt-6 mb-3">Functional Components</h3>
                    <p class="mb-4">FlexNet supports functional components, which are functions that accept props and return virtual DOM elements:</p>

                    <pre class="bg-gray-800 text-white p-4 rounded-lg mb-6"><code class="language-javascript">import { createElement, render } from './src/systems/render/functions.js';

// Define a functional component
const Greeting = ({ name }) => 
  createElement('div', { className: 'greeting' }, 
    `Hello, ${name}!`
  );

// Use the component
const element = createElement(Greeting, { name: 'World' });

// Render it
render(element, document.getElementById('root'));</code></pre>

                    <h2 class="text-2xl font-semibold mb-4 mt-8 border-b pb-2">Virtual DOM</h2>
                    <p class="mb-4">FlexNet JSX uses a virtual DOM approach to optimize rendering performance. The virtual DOM is a lightweight, immutable representation of the actual DOM structure.</p>

                    <h3 class="text-xl font-medium mt-6 mb-3">Virtual DOM Structure</h3>
                    <p class="mb-4">Each virtual DOM element has the following structure:</p>

                    <pre class="bg-gray-800 text-white p-4 rounded-lg mb-6"><code class="language-javascript">// Basic structure of a virtual DOM element
{
  type: 'div', // String for HTML elements, Function for components
  props: {
    className: 'container', // Regular DOM properties
    children: [...] // Child elements
  }
}</code></pre>

                    <h3 class="text-xl font-medium mt-6 mb-3">Diffing Algorithm</h3>
                    <p class="mb-4">When re-rendering, FlexNet compares the new virtual DOM with the previous one to determine the minimal set of changes needed to update the actual DOM.</p>

                    <div class="bg-white border border-gray-200 rounded-lg mb-6">
                        <div class="border-b border-gray-200 px-4 py-3 bg-gray-50">
                            <h4 class="font-semibold">How Diffing Works</h4>
                        </div>
                        <div class="p-4">
                            <ol class="list-decimal pl-6 space-y-2">
                                <li>Compare element types (tag names or component functions)</li>
                                <li>If types are different, replace the entire subtree</li>
                                <li>If types are the same, update only the changed properties</li>
                                <li>Recursively diff the children</li>
                                <li>Apply the minimal set of changes to the DOM</li>
                            </ol>
                        </div>
                    </div>

                    <h2 class="text-2xl font-semibold mb-4 mt-8 border-b pb-2">Rendering Process</h2>
                    <p class="mb-4">The rendering process in FlexNet JSX follows these steps:</p>

                    <div class="relative overflow-hidden mb-8">
                        <div class="border border-gray-200 rounded-lg bg-white p-6">
                            <ol class="list-decimal pl-6 space-y-4">
                                <li>
                                    <strong>Element Creation</strong>
                                    <p class="text-gray-600">Create virtual DOM elements using the <code>createElement</code> function or JSX syntax.</p>
                                </li>
                                <li>
                                    <strong>Component Resolution</strong>
                                    <p class="text-gray-600">For component elements, call the component function to get the rendered elements.</p>
                                </li>
                                <li>
                                    <strong>Tree Building</strong>
                                    <p class="text-gray-600">Build a complete virtual DOM tree by recursively resolving all components.</p>
                                </li>
                                <li>
                                    <strong>Diffing</strong>
                                    <p class="text-gray-600">Compare the new virtual DOM tree with the previous one.</p>
                                </li>
                                <li>
                                    <strong>Patch Generation</strong>
                                    <p class="text-gray-600">Generate a set of patches (operations) needed to update the DOM.</p>
                                </li>
                                <li>
                                    <strong>DOM Updates</strong>
                                    <p class="text-gray-600">Apply the patches to the actual DOM in a single batch.</p>
                                </li>
                                <li>
                                    <strong>Event Binding</strong>
                                    <p class="text-gray-600">Attach event handlers to the rendered elements.</p>
                                </li>
                            </ol>
                        </div>
                    </div>

                    <h3 class="text-xl font-medium mt-6 mb-3">Example: Rendering with State Updates</h3>
                    <pre class="bg-gray-800 text-white p-4 rounded-lg mb-6"><code class="language-javascript">import { createElement, render } from './src/systems/render/functions.js';
import { createStore } from './src/systems/state/functions.js';

// Create a store with initial state
const store = createStore({ count: 0 });

// Define a counter component
const Counter = ({ count, onIncrement }) =>
  createElement('div', null,
    createElement('h2', null, `Count: ${count}`),
    createElement('button', {
      onClick: onIncrement
    }, 'Increment')
  );

// Subscribe to state changes
store.subscribe(state => {
  // Render with new state when it changes
  render(
    createElement(Counter, {
      count: state.count,
      onIncrement: () => store.update(s => ({ count: s.count + 1 }))
    }),
    document.getElementById('root')
  );
});</code></pre>

                    <h2 class="text-2xl font-semibold mb-4 mt-8 border-b pb-2">Render API</h2>
                    <p class="mb-4">The FlexNet JSX render system provides the following core functions:</p>

                    <h3 class="text-xl font-medium mt-6 mb-3">render</h3>
                    <p class="mb-4">The primary function for rendering elements to the DOM.</p>
                    <pre class="bg-gray-800 text-white p-4 rounded-lg mb-6"><code class="language-javascript">/**
 * Render a virtual DOM element to a DOM container
 * @param {VNode} element - The virtual DOM element to render
 * @param {HTMLElement} container - The DOM container to render into
 * @returns {void}
 */
function render(element, container) {
  // Implementation details
}</code></pre>

                    <h3 class="text-xl font-medium mt-6 mb-3">createElement</h3>
                    <p class="mb-4">Creates virtual DOM elements that can be rendered.</p>
                    <pre class="bg-gray-800 text-white p-4 rounded-lg mb-6"><code class="language-javascript">/**
 * Create a virtual DOM element
 * @param {string|function} type - The element type (tag name or component function)
 * @param {object} props - The element properties
 * @param {...any} children - The element children
 * @returns {VNode} A virtual DOM node
 */
function createElement(type, props, ...children) {
  // Implementation details
}</code></pre>

                    <div class="bg-blue-50 border-l-4 border-primary p-4 rounded-md my-6">
                        <h4 class="font-semibold">Security Note</h4>
                        <p class="mt-2">For enhanced security, a safer version of <code>createElement</code> can be used, which validates inputs and returns an <code>Either</code> type to explicitly handle potential errors like invalid props or types. This prevents certain types of injection attacks. See the security guide for details.</p>
                    </div>

                    <h3 class="text-xl font-medium mt-6 mb-3">createFragment</h3>
                    <p class="mb-4">Creates a fragment that can hold multiple elements without adding extra DOM nodes.</p>
                    <pre class="bg-gray-800 text-white p-4 rounded-lg mb-6"><code class="language-javascript">/**
 * Create a virtual DOM fragment
 * @param {Array} children - The fragment children
 * @returns {VNode} A virtual DOM fragment
 */
function createFragment(children) {
  // Implementation details
}</code></pre>

                    <h2 class="text-2xl font-semibold mb-4 mt-8 border-b pb-2">Advanced Rendering Techniques</h2>
                    <p class="mb-4">FlexNet JSX supports several advanced rendering techniques:</p>

                    <h3 class="text-xl font-medium mt-6 mb-3">Conditional Rendering</h3>
                    <pre class="bg-gray-800 text-white p-4 rounded-lg mb-6"><code class="language-javascript">import { createElement } from './src/systems/render/functions.js';
import { Either } from './src/core/types/either.js';
import { pipe } from './src/core/functions/composition.js';

// Using Either for conditional rendering
const UserProfile = ({ user }) =>
  createElement('div', { className: 'profile' },
    // Render user info if user exists, otherwise render a login prompt
    pipe(
      Either.fold(
        () => [createElement('button', { onClick: () => { /* login */ } }, 'Log In')],
        (userData) => [
          createElement('h2', null, userData.name),
          createElement('p', null, userData.email)
        ]
      )
    )(Either.fromNullable(user))
  );</code></pre>

                    <h3 class="text-xl font-medium mt-6 mb-3">List Rendering</h3>
                    <pre class="bg-gray-800 text-white p-4 rounded-lg mb-6"><code class="language-javascript">import { createElement } from './src/systems/render/functions.js';

// Rendering lists with proper keys
const TodoList = ({ todos, onToggle }) =>
  createElement('ul', { className: 'todo-list' },
    todos.map(todo => 
      createElement('li', { 
        key: todo.id, // Unique key for efficient updates
        className: todo.completed ? 'completed' : ''
      },
        createElement('input', {
          type: 'checkbox',
          checked: todo.completed,
          onChange: () => onToggle(todo.id)
        }),
        createElement('span', null, todo.text)
      )
    )
  );</code></pre>

                    <h3 class="text-xl font-medium mt-6 mb-3">Error Boundaries</h3>
                    <p class="mb-4">FlexNet provides a way to handle rendering errors gracefully using a functional approach. One common pattern is to create an `ErrorBoundary` component that takes a function to execute and a fallback UI to render in case of an error.</p>
                    <pre class="bg-gray-800 text-white p-4 rounded-lg mb-6"><code class="language-javascript">import { createElement } from './src/systems/render/functions.js';
import { Result } from './src/core/types/result.js';

// Error boundary component using a render prop pattern
const ErrorBoundary = ({ childFn, fallback }) => {
  // Attempt to execute the function that may throw an error
  const renderResult = Result.fromTry(childFn);

  // Return the successful result or the fallback UI
  if (renderResult.type === 'Ok') {
    return renderResult.value;
  }
  
  return typeof fallback === 'function'
    ? fallback(renderResult.error)
    : fallback;
};

// Usage
const PotentiallyCrashingComponent = ({ user }) => {
  if (!user) {
    throw new Error('User data is missing!');
  }
  return createElement('h1', null, `Welcome, ${user.name}`);
};

const App = () =>
  createElement(ErrorBoundary, {
    fallback: (error) => createElement('div', { className: 'error' },
      `Something went wrong: ${error.message}`
    ),
    childFn: () => createElement(PotentiallyCrashingComponent, { user: currentUser })
  });</code></pre>

                    <h2 class="text-2xl font-semibold mb-4 mt-8 border-b pb-2">Optimizing Render Performance</h2>
                    <p class="mb-4">To optimize rendering performance in FlexNet JSX, consider the following techniques:</p>

                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                        <div class="bg-white p-4 border border-gray-200 rounded-lg">
                            <h4 class="font-semibold text-lg mb-2">Memoization</h4>
                            <p class="text-gray-600">Use the <code>memoize</code> function to prevent unnecessary re-renders of expensive components. This works best when component props are primitive values or simple objects that can be reliably serialized.</p>
                        </div>
                        <div class="bg-white p-4 border border-gray-200 rounded-lg">
                            <h4 class="font-semibold text-lg mb-2">Keys</h4>
                            <p class="text-gray-600">Always use unique keys when rendering lists to help the diffing algorithm identify changes efficiently.</p>
                        </div>
                        <div class="bg-white p-4 border border-gray-200 rounded-lg">
                            <h4 class="font-semibold text-lg mb-2">Granular Components</h4>
                            <p class="text-gray-600">Break UI into smaller, focused components to minimize the impact of state changes.</p>
                        </div>
                        <div class="bg-white p-4 border border-gray-200 rounded-lg">
                            <h4 class="font-semibold text-lg mb-2">Avoid Deep Nesting</h4>
                            <p class="text-gray-600">Excessively deep component hierarchies can slow down the diffing process.</p>
                        </div>
                    </div>

                    <h3 class="text-xl font-medium mt-6 mb-3">Example: Memoized Component</h3>
                    <pre class="bg-gray-800 text-white p-4 rounded-lg mb-6"><code class="language-javascript">import { createElement } from './src/systems/render/functions.js';
import { memoize } from './src/utils/function.js';

// Expensive component that shouldn't re-render unless its props change
const ExpensiveComponent = ({ data }) => {
  // Complex processing...
  const processedData = JSON.stringify(data); // Example of processing
  
  return createElement('div', null,
    createElement('p', null, `Processed: ${processedData}`)
  );
};

// Memoized version that only re-renders when its arguments change.
// The arguments are JSON.stringified to create a cache key.
const MemoizedExpensiveComponent = memoize(ExpensiveComponent);</code></pre>

                    <div class="bg-yellow-50 border-l-4 border-yellow-400 p-4 rounded-md mt-8">
                        <h4 class="font-semibold flex items-center">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2 text-yellow-500" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2h-1V9z" clip-rule="evenodd" />
                            </svg>
                            Tip
                        </h4>
                        <p>When working with the FlexNet JSX render system, embrace the functional programming paradigm. Use pure functions, immutable data structures, and composition to create predictable, maintainable, and efficient UIs.</p>
                    </div>
                </div>

                <div class="mt-12 border-t border-gray-200 pt-8">
                    <h2 class="text-2xl font-semibold mb-4">Next Steps</h2>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <a href="events.html" class="block p-4 border border-gray-200 rounded-lg hover:border-primary hover:shadow-md transition">
                            <h3 class="font-semibold text-lg mb-2">Events System</h3>
                            <p class="text-gray-600">Learn how FlexNet handles DOM events in a functional way.</p>
                        </a>
                        <a href="../api/jsx.html" class="block p-4 border border-gray-200 rounded-lg hover:border-primary hover:shadow-md transition">
                            <h3 class="font-semibold text-lg mb-2">JSX API Reference</h3>
                            <p class="text-gray-600">Explore the complete API reference for the JSX runtime.</p>
                        </a>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <footer id="footer-placeholder" class="bg-white border-t border-gray-200 py-6">
    </footer>

    <script src="../assets/main.js"></script>
</body>
</html> 