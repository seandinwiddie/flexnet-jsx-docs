<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Effects - FlexNet JSX Framework</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <link rel="stylesheet" href="../assets/main.css">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#3b82f6',
                        secondary: '#6366f1',
                        dark: '#1e293b',
                        light: '#f8fafc'
                    }
                }
            }
        }
        hljs.highlightAll();
    </script>
</head>
<body class="bg-gray-50 text-gray-900 min-h-screen">
    <div class="flex flex-col md:flex-row">
        <!-- Sidebar -->
        <aside id="sidebar-placeholder" class="w-full md:w-64 bg-white border-r border-gray-200 md:h-screen md:sticky top-0 overflow-y-auto">
        </aside>

        <!-- Main content -->
        <main class="flex-1">
            <header id="header-placeholder" class="border-b border-gray-200 bg-white sticky top-0 z-10">
            </header>

            <div class="p-8 max-w-4xl mx-auto">
                <div class="flex items-center space-x-2 text-sm text-gray-500 mb-8">
                    <a href="../index.html" class="hover:text-primary">Home</a>
                    <span>/</span>
                    <a href="state.html" class="hover:text-primary">Systems</a>
                    <span>/</span>
                    <span class="text-gray-700">Effects</span>
                </div>

                <h1 class="text-4xl font-bold mb-6">Effect System</h1>
                <p class="text-lg text-gray-600 mb-8">Learn how to manage side effects in a pure, functional, and composable way with the FlexNet JSX Effect System.</p>

                <div class="prose prose-blue max-w-none">
                    <h2 class="text-2xl font-semibold mb-4 mt-8 border-b pb-2" id="introduction">Introduction</h2>
                    <p class="mb-4">Side effects are an inevitable part of web applicationsâ€”from fetching data and setting timers to manipulating the DOM. The challenge in functional programming is to handle these side effects without sacrificing the purity and predictability of your functions.</p>
                    
                    <p class="mb-4">FlexNet's Effect System provides a solution by wrapping side effects in a pure, immutable data structure called an <code>Effect</code>. This approach allows you to:</p>
                    <ul class="list-disc pl-6 mb-6 space-y-2">
                        <li>Isolate side effects from pure business logic.</li>
                        <li>Treat effects as values that can be passed around, composed, and manipulated.</li>
                        <li>Defer the execution of impure code to a controlled boundary.</li>
                        <li>Write more testable and predictable code.</li>
                    </ul>

                    <h2 class="text-2xl font-semibold mb-4 mt-8 border-b pb-2" id="effect-model">The Monadic Effect Model</h2>
                    <p class="mb-4">In FlexNet, an <code>Effect</code> is a simple object that contains a function called <code>run</code>. This <code>run</code> function, when executed, performs the actual side effect. Until <code>run</code> is called, the <code>Effect</code> is just a description of a computation, making it a pure value.</p>

                    <div class="bg-white p-6 rounded-lg shadow-sm border border-gray-100 mb-6">
                        <h3 class="text-lg font-semibold mb-3">Effect Structure</h3>
                        <pre class="bg-gray-800 text-white p-4 rounded-lg"><code class="language-javascript">// The structure of an Effect value
const myEffect = {
  type: 'Effect',
  run: () => { /* ... side effect logic ... */ }
};</code></pre>
                    </div>

                    <h2 class="text-2xl font-semibold mb-4 mt-8 border-b pb-2" id="creating-and-running-effects">Creating and Running Effects</h2>
                    <p class="mb-4">You create an effect using <code>Effect.of</code> and execute it using <code>Effect.run</code>.</p>

                    <pre class="bg-gray-800 text-white p-4 rounded-lg mb-6"><code class="language-javascript">import { Effect } from './src/systems/effects/functions.js';

// Create an effect that gets an item from localStorage
const getItem = (key) => Effect.of(() => localStorage.getItem(key));

// At this point, no side effect has occurred. `getItem('myKey')` is just a value.

// Now, run the effect to actually read from localStorage
const result = Effect.run(getItem('myKey'));
console.log(result); // logs the value from localStorage</code></pre>

                    <div class="bg-blue-50 border-l-4 border-primary p-4 rounded-md mb-6">
                        <h4 class="font-semibold">Key Idea</h4>
                        <p>The separation between creating an effect and running it is the core principle. Your business logic should create and compose effects, while a single, top-level "end of the world" part of your application runs them.</p>
                    </div>

                    <h2 class="text-2xl font-semibold mb-4 mt-8 border-b pb-2" id="composing-effects">Composing Effects with `map` and `chain`</h2>
                    <p class="mb-4">The true power of the Effect system comes from its monadic nature, allowing you to compose effects using <code>map</code> and <code>chain</code>.</p>
                    
                    <h3 class="text-xl font-medium mt-6 mb-3">Transforming Effect Results with `map`</h3>
                    <p class="mb-4"><code>Effect.map</code> lets you apply a pure function to the result of an effect without running the effect.</p>
                    <pre class="bg-gray-800 text-white p-4 rounded-lg mb-6"><code class="language-javascript">import { Effect } from './src/systems/effects/functions.js';
import { pipe } from './src/core/functions/composition.js';

const getItem = (key) => Effect.of(() => localStorage.getItem(key));
const parseJson = (str) => JSON.parse(str);

// Create an effect that gets an item and then parses it as JSON
const getObject = (key) => pipe(
    Effect.map(parseJson)
)(getItem(key));

// The result of `run` will be the parsed object
const user = Effect.run(getObject('currentUser'));
                    </code></pre>

                    <h3 class="text-xl font-medium mt-6 mb-3">Sequencing Effects with `chain`</h3>
                    <p class="mb-4"><code>Effect.chain</code> lets you sequence effects, where the next effect depends on the result of the previous one.</p>
                     <pre class="bg-gray-800 text-white p-4 rounded-lg mb-6"><code class="language-javascript">import { Effect } from './src/systems/effects/functions.js';
import { pipe } from './src/core/functions/composition.js';

const getUserId = Effect.of(() => '123');
const fetchUserById = (id) => Effect.of(() => fetch(`https://api.example.com/users/${id}`));

// Chain the effects: get the ID, then use it to fetch the user
const fetchCurrentUser = pipe(
    Effect.chain(fetchUserById)
)(getUserId);

// `run` will return a Promise for the user data
Effect.run(fetchCurrentUser).then(response => response.json()).then(console.log);
                    </code></pre>


                    <h2 class="text-2xl font-semibold mb-4 mt-8 border-b pb-2" id="asynchronous-effects">Handling Asynchronous Effects</h2>
                    <p class="mb-4">The Effect system handles asynchronous operations naturally. If an effect's <code>run</code> function returns a <code>Promise</code>, then <code>Effect.run</code> will return that <code>Promise</code>.</p>
                    
                    <p class="mb-4">For robust error handling, it's best practice for async effects to return a <code>Promise</code> that resolves to a <code>Result</code> or <code>Either</code> type.</p>

                    <pre class="bg-gray-800 text-white p-4 rounded-lg mb-6"><code class="language-javascript">import { Effect } from './src/systems/effects/functions.js';
import { Result } from './src/core/types/result.js';

const safeFetch = (url, options) => Effect.of(() => 
    fetch(url, options)
        .then(res => {
            if (!res.ok) throw new Error(`HTTP Error: ${res.status}`);
            return res.json();
        })
        .then(data => Result.Ok(data))
        .catch(err => Result.Error(err))
);

// Use the effect
const fetchEffect = safeFetch('/api/users/1');

// Running the effect returns a Promise<Result>
Effect.run(fetchEffect)
    .then(result => {
        if (result.type === 'Ok') {
            console.log('Success:', result.value);
        } else {
            console.error('Failure:', result.error);
        }
});</code></pre>

                    <h2 class="text-2xl font-semibold mb-4 mt-8 border-b pb-2" id="resource-management">Resource Management and Cleanup</h2>
                    <p class="mb-4">While the base <code>Effect</code> type doesn't have a built-in cleanup mechanism, you can model it by having your effect's <code>run</code> function return the result along with a <code>cleanup</code> function.</p>

                    <pre class="bg-gray-800 text-white p-4 rounded-lg mb-6"><code class="language-javascript">import { Effect } from './src/systems/effects/functions.js';

const timerEffect = (onTick, interval) => Effect.of(() => {
    const timerId = setInterval(onTick, interval);
    
    // The cleanup function
    const cleanup = () => {
        console.log('Clearing timer...');
        clearInterval(timerId);
  };

    // The effect's "result" is the cleanup function itself
    return { cleanup };
});

// Run the effect
const { cleanup } = Effect.run(timerEffect(() => console.log('tick'), 1000));

// Later, when the effect is no longer needed...
// setTimeout(cleanup, 5000);
                    </code></pre>

                     <p class="mb-4">This pattern is especially useful for managing cancellable fetches:</p>

                     <pre class="bg-gray-800 text-white p-4 rounded-lg mb-6"><code class="language-javascript">const cancellableFetch = (url) => Effect.of(() => {
    const controller = new AbortController();
    
    const promise = fetch(url, { signal: controller.signal })
        .then(res => res.json());
        
    const cleanup = () => controller.abort();
    
    return { promise, cleanup };
});

const { promise, cleanup } = Effect.run(cancellableFetch('/api/data'));

promise.then(console.log).catch(err => {
    if (err.name === 'AbortError') {
        console.log('Fetch aborted!');
    }
});

// If you need to cancel the request:
// cleanup();
                    </code></pre>

                    <h2 class="text-2xl font-semibold mb-4 mt-8 border-b pb-2" id="effects-with-state">Effects and State Management</h2>
                    <p class="mb-4">Effects should remain separate from state updates. The correct pattern is to run an effect, get its result, and then dispatch an action to the state store based on that result.</p>

                    <pre class="bg-gray-800 text-white p-4 rounded-lg mb-6"><code class="language-javascript">import { createStore } from './src/systems/state/functions.js';
import { Effect } from './src/systems/effects/functions.js';
import { Result } from './src/core/types/result.js';

// Assume a store and actions are defined
const store = createStore(reducer, { data: null, loading: true, error: null });
const actions = {
    fetchSuccess: (data) => ({ type: 'FETCH_SUCCESS', payload: data }),
    fetchError: (error) => ({ type: 'FETCH_ERROR', payload: error })
};

// 1. Define your effect
const fetchUserEffect = (userId) => Effect.of(() =>
  fetch(`/api/users/${userId}`)
        .then(res => res.json())
        .then(data => Result.Ok(data))
        .catch(err => Result.Error(err))
);
  
// 2. Run the effect and dispatch actions based on the result
const loadUser = (userId) => {
    const effect = fetchUserEffect(userId);
    
    Effect.run(effect).then(result => {
        if (result.type === 'Ok') {
            store.dispatch(actions.fetchSuccess(result.value));
  } else {
            store.dispatch(actions.fetchError(result.error));
        }
  });
};

// 3. Trigger the process
loadUser('123');
                    </code></pre>

                    <h2 class="text-2xl font-semibold mb-4 mt-8 border-b pb-2" id="best-practices">Best Practices</h2>
                    
                    <div class="bg-gray-100 p-6 rounded-lg mb-6">
                        <h3 class="text-lg font-semibold mb-3">Effect Best Practices</h3>
                        <ul class="space-y-4">
                            <li class="flex">
                                <div class="mr-4 flex-shrink-0">
                                    <span class="inline-flex items-center justify-center h-8 w-8 rounded-full bg-blue-100 text-blue-500 text-lg font-bold">1</span>
                                </div>
                                <div>
                                    <h4 class="font-medium">Keep Your Logic Pure</h4>
                                    <p class="text-gray-600">Your functions should create and compose effects. Defer running them to the edges of your application.</p>
                                </div>
                            </li>
                            <li class="flex">
                                <div class="mr-4 flex-shrink-0">
                                    <span class="inline-flex items-center justify-center h-8 w-8 rounded-full bg-blue-100 text-blue-500 text-lg font-bold">2</span>
                                </div>
                                <div>
                                    <h4 class="font-medium">Embrace Composition</h4>
                                    <p class="text-gray-600">Use <code>map</code> and <code>chain</code> to build complex logic from small, reusable effects.</p>
                                </div>
                            </li>
                            <li class="flex">
                                <div class="mr-4 flex-shrink-0">
                                    <span class="inline-flex items-center justify-center h-8 w-8 rounded-full bg-blue-100 text-blue-500 text-lg font-bold">3</span>
                                </div>
                                <div>
                                    <h4 class="font-medium">Explicitly Model Cleanup</h4>
                                    <p class="text-gray-600">For effects that create subscriptions or resources, have them return a <code>cleanup</code> function as part of their result.</p>
                                </div>
                            </li>
                            <li class="flex">
                                <div class="mr-4 flex-shrink-0">
                                    <span class="inline-flex items-center justify-center h-8 w-8 rounded-full bg-blue-100 text-blue-500 text-lg font-bold">4</span>
                                </div>
                                <div>
                                    <h4 class="font-medium">Use `Result` for Fallible Effects</h4>
                                    <p class="text-gray-600">For effects that can fail (like network requests), wrap their results in a <code>Result</code> or <code>Either</code> type to handle errors functionally.</p>
                                </div>
                            </li>
                        </ul>
                    </div>

                    <h2 class="text-2xl font-semibold mb-4 mt-8 border-b pb-2" id="api-reference">API Reference</h2>
                    <p class="mb-4">The core <code>Effect</code> API is defined in <code>/src/systems/effects/functions.js</code>.</p>
                    
                    <h3 class="text-xl font-medium mt-6 mb-3">Effect.of</h3>
                    <div class="bg-white p-4 rounded-lg border border-gray-200 mb-6">
                        <pre class="bg-gray-800 text-white p-4 rounded-lg mb-2"><code class="language-javascript">Effect.of(value: () => a): Effect<a></code></pre>
                        <p>Wraps a thunk (a zero-argument function) into an Effect. The computation is not performed until <code>run</code> is called.</p>
                    </div>
                        
                    <h3 class="text-xl font-medium mt-6 mb-3">Effect.run</h3>
                     <div class="bg-white p-4 rounded-lg border border-gray-200 mb-6">
                        <pre class="bg-gray-800 text-white p-4 rounded-lg mb-2"><code class="language-javascript">Effect.run(effect: Effect<a>): a</code></pre>
                        <p>Executes the given effect and returns the result of its computation.</p>
                    </div>

                    <h3 class="text-xl font-medium mt-6 mb-3">Effect.map</h3>
                    <div class="bg-white p-4 rounded-lg border border-gray-200 mb-6">
                        <pre class="bg-gray-800 text-white p-4 rounded-lg mb-2"><code class="language-javascript">Effect.map(fn: (a) => b): (effect: Effect<a>) => Effect<b></code></pre>
                        <p>Returns a new effect that will apply the pure function <code>fn</code> to the result of the original effect.</p>
                    </div>

                    <h3 class="text-xl font-medium mt-6 mb-3">Effect.chain</h3>
                    <div class="bg-white p-4 rounded-lg border border-gray-200 mb-6">
                        <pre class="bg-gray-800 text-white p-4 rounded-lg mb-2"><code class="language-javascript">Effect.chain(fn: (a) => Effect<b>): (effect: Effect<a>) => Effect<b></code></pre>
                        <p>Returns a new effect by applying a function <code>fn</code> (that returns a new effect) to the result of the original effect. Used for sequencing.</p>
                    </div>

                    <h2 class="text-2xl font-semibold mb-4 mt-8 border-b pb-2" id="next-steps">Next Steps</h2>
                    
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-8">
                        <a href="state.html" class="block p-4 border border-gray-200 rounded-lg hover:border-primary hover:shadow-md transition">
                            <h3 class="font-semibold text-lg mb-2">State Management</h3>
                            <p class="text-gray-600">Learn how to use FlexNet's state management system.</p>
                        </a>
                        <a href="render.html" class="block p-4 border border-gray-200 rounded-lg hover:border-primary hover:shadow-md transition">
                            <h3 class="font-semibold text-lg mb-2">Render System</h3>
                            <p class="text-gray-600">Explore the rendering system in depth.</p>
                        </a>
                        <a href="../examples/todo.html" class="block p-4 border border-gray-200 rounded-lg hover:border-primary hover:shadow-md transition">
                            <h3 class="font-semibold text-lg mb-2">Todo App Example</h3>
                            <p class="text-gray-600">See effects in action in a complete application.</p>
                        </a>
                        <a href="../api/result.html" class="block p-4 border border-gray-200 rounded-lg hover:border-primary hover:shadow-md transition">
                            <h3 class="font-semibold text-lg mb-2">Result Type</h3>
                            <p class="text-gray-600">Learn about the Result type, which is essential for handling effects that can fail.</p>
                        </a>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <footer id="footer-placeholder" class="bg-white border-t border-gray-200 py-6">
    </footer>

    <script src="../assets/main.js"></script>
</body>
</html> 