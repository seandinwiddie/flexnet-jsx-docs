<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Error Handling - FlexNet JSX Framework</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#3b82f6',
                        secondary: '#6366f1',
                        dark: '#1e293b',
                        light: '#f8fafc'
                    }
                }
            }
        }
        hljs.highlightAll();
    </script>
</head>
<body class="bg-gray-50 text-gray-900 min-h-screen">
    <div class="flex">
        <!-- Sidebar -->
        <aside id="sidebar-placeholder" class="w-64 bg-white border-r border-gray-200 h-screen sticky top-0 overflow-y-auto flex-shrink-0">
        </aside>

        <!-- Main content -->
        <main class="flex-1 overflow-y-auto">
            <header id="header-placeholder" class="border-b border-gray-200 bg-white sticky top-0 z-10">
            </header>

            <div class="p-8 max-w-5xl mx-auto">
                <div class="flex items-center space-x-2 text-sm text-gray-500 mb-8">
                    <a href="../index.html" class="hover:text-primary">Home</a>
                    <span>/</span>
                    <a href="state.html" class="hover:text-primary">Systems</a>
                    <span>/</span>
                    <span class="text-gray-700">Error Handling</span>
                </div>

                <h1 class="text-4xl font-bold mb-6">Error Handling</h1>
                <p class="text-lg text-gray-600 mb-8">FlexNet JSX treats errors as manageable data, not as disruptive, unhandled exceptions. This is achieved by using a functional approach where operations that can fail return special container types that explicitly model success and failure paths.</p>

                <div class="prose prose-blue max-w-none">
                    <h2 class="text-2xl font-semibold mb-4 mt-8 border-b pb-2">Functional Error Handling Philosophy</h2>
                    <p class="mb-4">FlexNet JSX takes a functional approach to error handling, based on these core principles:</p>

                    <div class="bg-blue-50 border-l-4 border-primary p-4 rounded-md mb-6">
                        <h4 class="font-semibold">Core Principles</h4>
                        <ul class="list-disc pl-6 mt-2">
                            <li>Errors are values, not exceptions</li>
                            <li>Error paths are explicit and type-safe</li>
                            <li>Error handling is composable</li>
                            <li>Errors are isolated and don't cause cascading failures</li>
                            <li>Runtime exceptions are minimized by design</li>
                        </ul>
                    </div>

                    <h2 class="text-2xl font-semibold mb-4 mt-8 border-b pb-2">Error Handling Types</h2>
                    <p class="mb-4">FlexNet JSX provides three core types for handling different error scenarios:</p>

                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                        <div class="bg-white p-4 border border-gray-200 rounded-lg">
                            <h4 class="font-semibold text-lg mb-2">Maybe</h4>
                            <p class="text-gray-600">For representing optional values that might be missing, but aren't errors.</p>
                            <div class="mt-2 text-sm text-primary">
                                <a href="../api/maybe.html" class="hover:underline">View Documentation →</a>
                            </div>
                        </div>
                        <div class="bg-white p-4 border border-gray-200 rounded-lg">
                            <h4 class="font-semibold text-lg mb-2">Either</h4>
                            <p class="text-gray-600">For representing synchronous computations that can either succeed (Right) or fail with an error value (Left).</p>
                            <div class="mt-2 text-sm text-primary">
                                <a href="../api/either.html" class="hover:underline">View Documentation →</a>
                            </div>
                        </div>
                        <div class="bg-white p-4 border border-gray-200 rounded-lg">
                            <h4 class="font-semibold text-lg mb-2">Result</h4>
                            <p class="text-gray-600">For representing operations (often asynchronous) that can succeed (Ok) or fail (Error).</p>
                            <div class="mt-2 text-sm text-primary">
                                <a href="../api/result.html" class="hover:underline">View Documentation →</a>
                            </div>
                        </div>
                    </div>

                    <h3 class="text-xl font-medium mt-6 mb-3">When to Use Each Type</h3>

                    <div class="bg-white border border-gray-200 rounded-lg mb-6">
                        <div class="border-b border-gray-200 px-4 py-3 bg-gray-50">
                            <h4 class="font-semibold">Choosing the Right Type</h4>
                        </div>
                        <div class="p-4">
                            <table class="min-w-full divide-y divide-gray-200">
                                <thead>
                                    <tr>
                                        <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Type</th>
                                        <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Use Case</th>
                                        <th class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Example</th>
                                    </tr>
                                </thead>
                                <tbody class="divide-y divide-gray-200">
                                    <tr>
                                        <td class="px-4 py-3"><code>Maybe</code></td>
                                        <td class="px-4 py-3">When a value might be absent, but that's not an error</td>
                                        <td class="px-4 py-3">User profile that might not exist yet</td>
                                    </tr>
                                    <tr>
                                        <td class="px-4 py-3"><code>Either</code></td>
                                        <td class="px-4 py-3">When an operation can fail with a specific error value</td>
                                        <td class="px-4 py-3">Form validation with validation errors</td>
                                    </tr>
                                    <tr>
                                        <td class="px-4 py-3"><code>Result</code></td>
                                        <td class="px-4 py-3">For async operations that can succeed or fail</td>
                                        <td class="px-4 py-3">API calls, file operations</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <h2 class="text-2xl font-semibold mb-4 mt-8 border-b pb-2">Handling Optional Values with `Maybe`</h2>
                    <p class="mb-4">The <code>Maybe</code> type is used for optional values. Instead of returning `null` or `undefined`, a function returns `Maybe.Nothing()` to indicate a legitimate absence of a value, preventing null reference errors.</p>

                    <pre class="bg-gray-800 text-white p-4 rounded-lg mb-6"><code class="language-javascript">import { Maybe } from '/src/core/types/maybe.js';
import { createElement } from '/src/core/runtime/jsx.js';

// Example: get a user from storage, which might not exist.
const findUser = (id) => id === 1 ? { id: 1, name: 'Admin' } : null;
const maybeUser = Maybe.fromNullable(findUser(1));

// Use `map` to safely access properties and `getOrElse` for a default.
const greeting = maybeUser
  .map(user => `Hello, ${user.name}!`)
  .getOrElse('Hello, Guest!');

// console.log(greeting); // => "Hello, Admin!"

// Rendering UI with Maybe
const UserProfile = ({ userMaybe }) =>
  createElement('div', { className: 'profile' },
    userMaybe.map(user => [
        createElement('h2', null, user.name),
        createElement('p', null, user.email)
    ]).getOrElse(
        createElement('p', null, 'Please log in to view your profile')
    )
  ).getOrElse(null); // Assuming createElement is safe
</code></pre>

                    <h2 class="text-2xl font-semibold mb-4 mt-8 border-b pb-2">Handling Synchronous Errors with `Either`</h2>
                    <p class="mb-4">The <code>Either</code> type represents a computation that can result in one of two outcomes: a `Right` for success or a `Left` for failure. It is ideal for operations like validation, where you need to capture a specific error message.</p>

                    <pre class="bg-gray-800 text-white p-4 rounded-lg mb-6"><code class="language-javascript">import { Either } from '/src/core/types/either.js';
import { pipe } from '/src/core/functions/composition.js';

const validateEmail = email =>
  !email ? Either.Left('Email is required')
  : !/\S+@\S+\.\S+/.test(email) ? Either.Left('Email is invalid')
  : Either.Right(email);

const validatePassword = password =>
  !password ? Either.Left('Password is required')
  : password.length < 8 ? Either.Left('Password must be at least 8 characters')
  : Either.Right(password);

// `fold` is used to handle both possible outcomes.
const displayValidationResult = (either) => either.fold(
    error => `Validation failed: ${error}`,
    value => `Validation succeeded for: ${value}`
);

const emailResult = validateEmail('test@example.com');
const passwordResult = validatePassword('123');

// console.log(displayValidationResult(emailResult));   // => "Validation succeeded for: test@example.com"
// console.log(displayValidationResult(passwordResult)); // => "Validation failed: Password must be at least 8 characters"
</code></pre>

                    <h2 class="text-2xl font-semibold mb-4 mt-8 border-b pb-2">Composing Validation Chains</h2>
                    <p class="mb-4">The true power of `Either` is revealed when you chain multiple validation steps together. The chain will short-circuit on the first `Left`, or continue if `Right`.</p>

                    <pre class="bg-gray-800 text-white p-4 rounded-lg mb-6"><code class="language-javascript">import { Either } from '/src/core/types/either.js';
import { pipe } from '/src/core/functions/composition.js';

// Assume validateEmail and validatePassword from the previous example.

const validateLogin = (email, password) =>
  validateEmail(email).chain(validEmail =>
    validatePassword(password).map(validPassword => ({
      email: validEmail,
      password: validPassword
    }))
  );

// Using the composed validation
const loginResult = validateLogin('test@example.com', 'password123');

loginResult.fold(
  error => console.error(`Login failed: ${error}`),
  credentials => console.log('Login successful:', credentials)
);
</code></pre>

                    <h2 class="text-2xl font-semibold mb-4 mt-8 border-b pb-2">Handling Asynchronous Errors with `Result`</h2>
                    <p class="mb-4">The <code>Result</code> type is designed for asynchronous operations that can either succeed (`Ok`) or fail (`Error`), such as API calls. It cleanly wraps Promises or `try/catch` logic.</p>

                    <pre class="bg-gray-800 text-white p-4 rounded-lg mb-6"><code class="language-javascript">import { Result } from '/src/core/types/result.js';
import { pipe } from '/src/core/functions/composition.js';

// A fold helper for Result, as it's not in the core API but is a common pattern.
const foldResult = (onOk, onError) => result =>
    result.type === 'Ok' ? onOk(result.value) : onError(result.error);

// 1. Wrapping a fetch call
const fetchUser = async (userId) => {
    try {
        const response = await fetch(`/api/users/${userId}`);
        if (!response.ok) return Result.Error(`Request failed: ${response.status}`);
        const data = await response.json();
        return Result.Ok(data);
    } catch (e) {
        return Result.Error(e);
    }
};

// 2. Wrapping a try/catch block
const parseJSON = (jsonString) => Result.fromTry(() => JSON.parse(jsonString));


// --- Usage ---
const userResult = await fetchUser(123);

foldResult(
  user => console.log('Fetched User:', user),
  error => console.error('Fetch Error:', error)
)(userResult);


const jsonResult = parseJSON('{"name": "John"}');

const name = foldResult(
    data => data.name,
    error => 'Unknown'
)(jsonResult);

// console.log(name); // => "John"
</code></pre>

                    <h2 class="text-2xl font-semibold mb-4 mt-8 border-b pb-2">Functional Error Boundaries</h2>
                    <p class="mb-4">In FlexNet JSX, an "error boundary" is not a special component, but a pattern of functional composition. A component that might fail returns an `Either` type. The parent component then uses `fold` to decide whether to render the successful result or a fallback UI.</p>

                    <pre class="bg-gray-800 text-white p-4 rounded-lg mb-6"><code class="language-javascript">import { createElement } from '/src/core/runtime/jsx.js';
import { Either } from '/src/core/types/either.js';

// This component can fail if user data is invalid.
// It returns an Either<Error, VNode>
const UserDashboard = ({ user }) => {
    if (!user || !user.name) {
        return Either.Left(new Error('Invalid user data provided to UserDashboard.'));
    }

    return Either.Right(
        createElement('div', null,
            createElement('h1', null, `Welcome, ${user.name}`)
        )
    );
};

// The parent component acts as the error boundary.
const App = ({ user }) => {
    const dashboardOrError = UserDashboard({ user });

    return dashboardOrError.fold(
        // The 'Left' case (failure): render a fallback UI.
        error => createElement('div', { className: 'error-container' },
            createElement('h2', null, 'Something went wrong'),
            createElement('p', null, error.message)
        ),
        // The 'Right' case (success): render the component as is.
        dashboardVNode => dashboardVNode
    );
};

// --- Rendering ---
// const validUser = { name: 'Alice' };
// render(App({ user: validUser }), document.getElementById('root'));
//
// const invalidUser = {};
// render(App({ user: invalidUser }), document.getElementById('root'));
</code></pre>

                    <div class="bg-yellow-50 border-l-4 border-yellow-400 p-4 rounded-md mt-8">
                        <h4 class="font-semibold flex items-center">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2 text-yellow-500" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2h-1V9z" clip-rule="evenodd" />
                            </svg>
                            Best Practices
                        </h4>
                        <ul class="list-disc pl-6 mt-2">
                            <li>Use the appropriate type for each scenario: `Maybe` for optionality, `Either` for synchronous failure, and `Result` for asynchronous failure.</li>
                            <li>Embrace the pipeline: Use `map` and `chain` to compose operations that can fail, letting errors propagate cleanly.</li>
                            <li>Handle all paths: Use `fold` (for `Either`) or `getOrElse` (for `Maybe`) to explicitly handle both success and failure cases.</li>
                            <li>Avoid `try/catch`: Wrap potentially exception-throwing code with `Result.fromTry` to convert exceptions into data.</li>
                            <li>Components as functions: A component that can fail should return an `Either<Error, VNode>` to be handled by its parent.</li>
                        </ul>
                    </div>
                </div>

                <div class="mt-12 border-t border-gray-200 pt-8">
                    <h2 class="text-2xl font-semibold mb-4">Next Steps</h2>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <a href="../api/maybe.html" class="block p-4 border border-gray-200 rounded-lg hover:border-primary hover:shadow-md transition">
                            <h3 class="font-semibold text-lg mb-2">Maybe API</h3>
                            <p class="text-gray-600">Learn about the Maybe type for handling optional values.</p>
                        </a>
                        <a href="../api/either.html" class="block p-4 border border-gray-200 rounded-lg hover:border-primary hover:shadow-md transition">
                            <h3 class="font-semibold text-lg mb-2">Either API</h3>
                            <p class="text-gray-600">Explore the Either type for handling computational errors.</p>
                        </a>
                        <a href="../api/result.html" class="block p-4 border border-gray-200 rounded-lg hover:border-primary hover:shadow-md transition">
                            <h3 class="font-semibold text-lg mb-2">Result API</h3>
                            <p class="text-gray-600">Understand the Result type for handling asynchronous errors.</p>
                        </a>
                        <a href="../examples/todo.html" class="block p-4 border border-gray-200 rounded-lg hover:border-primary hover:shadow-md transition">
                            <h3 class="font-semibold text-lg mb-2">Todo App Example</h3>
                            <p class="text-gray-600">See error handling in action in a complete application.</p>
                        </a>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <footer id="footer-placeholder" class="bg-white border-t border-gray-200 py-6">
    </footer>

    <script src="../assets/main.js"></script>
</body>
</html> 