<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>State Management - FlexNet JSX Framework</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <link rel="stylesheet" href="../assets/main.css">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#3b82f6',
                        secondary: '#6366f1',
                        dark: '#1e293b',
                        light: '#f8fafc'
                    }
                }
            }
        }
        hljs.highlightAll();
    </script>
</head>
<body class="bg-gray-50 text-gray-900 min-h-screen">
    <div class="flex flex-col md:flex-row">
        <!-- Sidebar -->
        <aside id="sidebar-placeholder" class="w-full md:w-64 bg-white border-r border-gray-200 md:h-screen md:sticky top-0 overflow-y-auto">
        </aside>

        <!-- Main content -->
        <main class="flex-1">
            <header id="header-placeholder" class="border-b border-gray-200 bg-white sticky top-0 z-10">
            </header>

            <div class="p-8 max-w-4xl mx-auto">
                <div class="flex items-center space-x-2 text-sm text-gray-500 mb-8">
                    <a href="../index.html" class="hover:text-primary">Home</a>
                    <span>/</span>
                    <a href="state.html" class="hover:text-primary">Systems</a>
                    <span>/</span>
                    <span class="text-gray-700">State Management</span>
                </div>
                
                <h1 class="text-4xl font-bold mb-6">State Management</h1>
                <p class="text-lg text-gray-600 mb-8">FlexNet JSX implements a functional, immutable, and predictable approach to state management using a centralized store and pure reducer functions.</p>

                <div class="prose prose-blue max-w-none">
                    <h2 class="text-2xl font-semibold mb-4 mt-8 border-b pb-2">Core Principles</h2>
                    <ul class="list-disc pl-6 mb-6 space-y-2">
                        <li><strong>Single Source of Truth:</strong> The entire state of your application is stored in a single object tree within a single store.</li>
                        <li><strong>State is Read-Only:</strong> The only way to change the state is to dispatch an action, an object describing what happened.</li>
                        <li><strong>Changes are Made with Pure Functions:</strong> To specify how the state tree is transformed by actions, you write pure reducers.</li>
                        <li><strong>Unidirectional Data Flow:</strong> State changes flow in one direction: an action is dispatched, the reducer calculates the new state, and subscribers are notified.</li>
                    </ul>
                    
                    <h2 class="text-2xl font-semibold mb-4 mt-8 border-b pb-2">The Store, Reducers, and Actions</h2>
                    <p class="mb-4">The three core components of FlexNet state management are the store, reducers, and actions.</p>

                    <h3 class="text-xl font-medium mt-6 mb-3">The Store</h3>
                    <p class="mb-4">The store holds the application state, allows access to the state via <code>getState()</code>, allows state to be updated via <code>dispatch(action)</code>, and registers listeners via <code>subscribe(listener)</code>.</p>
                    <pre><code class="language-javascript">// src/systems/state/functions.js
import { pipe } from '../../core/functions/composition.js';

const createStore = (reducer, initialState) => {
    const subscribers = new Set();
    let state = initialState;

    return {
        getState: () => state,
        dispatch: action =>
            pipe(
                reducer(state),
                newState => { state = newState; },
                () => subscribers.forEach(fn => fn())
            )(action),
        subscribe: fn => {
            subscribers.add(fn);
            return () => subscribers.delete(fn);
        }
    };
};</code></pre>

                    <h3 class="text-xl font-medium mt-6 mb-3">Actions</h3>
                     <p class="mb-4">Actions are plain JavaScript objects that represent an intention to change the state. They must have a <code>type</code> property.</p>
                    <pre><code class="language-javascript">// An action to increment a counter
const incrementAction = { type: 'INCREMENT' };

// An action to add a todo, with a payload
const addTodoAction = { 
  type: 'ADD_TODO',
  payload: 'Learn functional programming'
};</code></pre>

                    <h3 class="text-xl font-medium mt-6 mb-3">Reducers</h3>
                    <p class="mb-4">A reducer is a pure, curried function that specifies how the application's state changes in response to an action. It has the signature: <code>state => action => newState</code>.</p>
                     <pre><code class="language-javascript">// A reducer for a simple counter
const counterReducer = state => action => {
  switch (action.type) {
    case 'INCREMENT':
      return state + 1;
    case 'DECREMENT':
      return state - 1;
    default:
      return state; // MUST handle the default case
  }
};</code></pre>

                    <h2 class="text-2xl font-semibold mb-4 mt-8 border-b pb-2">Usage Example: A Simple Counter</h2>
                    <p class="mb-4">Let's tie these concepts together with a basic counter example.</p>
                    <pre><code class="language-javascript">import { createStore } from './src/systems/state/functions.js';

// 1. The reducer
const counterReducer = state => action => {
  switch (action.type) {
    case 'INCREMENT': return state + 1;
    case 'DECREMENT': return state - 1;
    default: return state;
  }
};

// 2. Create the store
const store = createStore(counterReducer, 0);

// 3. Subscribe to changes to update the UI
const unsubscribe = store.subscribe(() => {
  console.log('State changed:', store.getState());
});

// 4. Dispatch actions to update the state
store.dispatch({ type: 'INCREMENT' }); // Logs: State changed: 1
store.dispatch({ type: 'INCREMENT' }); // Logs: State changed: 2
store.dispatch({ type: 'DECREMENT' }); // Logs: State changed: 1

// 5. Unsubscribe when the listener is no longer needed
unsubscribe();
                    </code></pre>
                
                    <h2 class="text-2xl font-semibold mb-4 mt-8 border-b pb-2">Complex State Updates: Todo List</h2>
                    <p class="mb-4">The reducer pattern scales well for more complex state structures like a todo list.</p>
                    <pre><code class="language-javascript">// Action creator functions
const addTodo = (text) => ({ type: 'ADD_TODO', payload: { id: Date.now(), text, completed: false } });
const toggleTodo = (id) => ({ type: 'TOGGLE_TODO', payload: { id } });

// The todos reducer
const todosReducer = state => action => {
  switch (action.type) {
    case 'ADD_TODO':
      return [...state, action.payload];
    case 'TOGGLE_TODO':
      return state.map(todo =>
        todo.id === action.payload.id
          ? { ...todo, completed: !todo.completed }
          : todo
      );
    default:
      return state;
  }
};

const todosStore = createStore(todosReducer, []);

todosStore.dispatch(addTodo('Learn FlexNet'));
todosStore.dispatch(addTodo('Build an app'));
todosStore.dispatch(toggleTodo(todosStore.getState()[0].id));

console.log(todosStore.getState());
                    </code></pre>
                
                    <h2 class="text-2xl font-semibold mb-4 mt-8 border-b pb-2">Integration with FlexNet Types</h2>
                    <p class="mb-4">FlexNet's state management integrates seamlessly with its functional types, allowing you to create robust, type-safe state containers.</p>
                
                    <h3 class="text-xl font-medium mt-6 mb-3">Using Maybe for Optional State</h3>
                    <p class="mb-4">A reducer can manage a state that is a <code>Maybe</code> type, which is perfect for handling optional data like a logged-in user.</p>
                    <pre><code class="language-javascript">import { Maybe } from './src/core/types/maybe.js';

// The state is Maybe<User>
const userProfileReducer = state => action => {
    switch (action.type) {
        case 'FETCH_USER_SUCCESS':
            return Maybe.Just(action.payload);
        case 'FETCH_USER_FAILURE':
        case 'LOGOUT':
            return Maybe.Nothing();
        default:
            return state;
    }
};

const userStore = createStore(userProfileReducer, Maybe.Nothing());

// Dispatch actions
userStore.dispatch({ type: 'FETCH_USER_SUCCESS', payload: { name: 'Alice' } });

// Get user display name safely
const displayName = userStore.getState()
    .map(profile => profile.name)
    .getOrElse('Anonymous'); // "Alice"
                    </code></pre>
                
                    <h3 class="text-xl font-medium mt-6 mb-3">Using Either for Error Handling</h3>
                    <p class="mb-4">You can use an <code>Either</code> as your state to model data that can be in one of two states, such as valid data or an error.</p>
                    <pre><code class="language-javascript">import { Either } from './src/core/types/either.js';

// The state is Either<Error, FormData>
const formReducer = state => action => {
  if (action.type === 'UPDATE_FIELD') {
    const { field, value } = action.payload;
    const currentData = state.getOrElse({ email: '', password: '' });
    const newData = { ...currentData, [field]: value };
    
    // Perform validation, returning a Left for an error, or a Right for valid data
    if (!newData.email) {
      return Either.Left('Email is required');
    }
    if (!/\S+@\S+\.\S+/.test(newData.email)) {
      return Either.Left('Email is invalid');
    }
    return Either.Right(newData);
  }
  return state;
};

const formStore = createStore(formReducer, Either.Right({ email: '', password: '' }));

formStore.dispatch({ type: 'UPDATE_FIELD', payload: { field: 'email', value: 'invalid-email' } });

// Handle form state
formStore.getState().fold(
  error => console.error('Form has errors:', error), // This will run
  data => console.log('Submitting data:', data)
);
                    </code></pre>
                </div>
            </div>
        </main>
    </div>

    <footer id="footer-placeholder" class="bg-white border-t border-gray-200 py-6">
    </footer>

    <script src="../assets/main.js"></script>
</body>
</html>